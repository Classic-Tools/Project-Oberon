MODULE DOCS;  (*NW 7.6.87 / 18.3.93*) (* 5.10.93 BM Number scanning/ KR Inline & export*)

	IMPORT Reals, Texts, Oberon;

	(*symbols:
		|	0			1			2			3			4
	 ---|--------------------------------------------------------
		0 |	null		*			/			DIV			MOD
		5 |	&			+			-			OR			=
	 10 |	#			<			<=			>			>=
	 15 |	IN		 IS		 ^			.			,
	 20 |	:			..		 )			]			}
	 25 |	OF		 THEN		DO			TO			(
	 30 |	[			{			~			:=			number
	 35 |	NIL		string	 ident		;			|
	 40 |	END		ELSE		ELSIF		UNTIL		IF
	 45 |	CASE		WHILE		REPEAT		LOOP		 WITH		
	 50 |	EXIT		RETURN	 ARRAY		RECORD		POINTER
	 55 |	BEGIN		CONST		TYPE		VAR			PROCEDURE
	 60 |	IMPORT	 MODULE	 eof	 FOR	 BY *)	(* FOR, BY <-- ARD *)

	CONST KW = 47;	(*size of hash table*)
				maxDig = 32;
				maxExp = 38; maxLExp = 308;
				maxStrLen = 128;

	(*name, numtyp, intval, realval, lrlval are implicit results of Get*)

	VAR numtyp* : INTEGER; (* 1 = char, 2 = integer, 3 = real, 4 = longreal*)
		intval* : LONGINT;
		realval*: REAL;
		lrlval*: LONGREAL;
		scanerr*, MarkErrors*: BOOLEAN;
		
		name*: ARRAY maxStrLen OF CHAR;

		R*: Texts.Reader; (* << KR export *)
		W: Texts.Writer;

		ch*, prev: CHAR;			(* << KR export *) (*current and previous	characters*)
		lastpos: LONGINT; (*error position in source file*)

		warning: BOOLEAN;
		i: INTEGER;
		keyTab	: ARRAY KW OF RECORD symb, alt: INTEGER; id: ARRAY 12 OF CHAR END;
		cmd : INTEGER; (* << KR *)

	PROCEDURE Mark*(n: INTEGER);
		VAR pos: LONGINT;
	BEGIN 
		IF MarkErrors THEN 
			pos := Texts.Pos(R);
			IF n < 0 THEN 
			ELSE scanerr := TRUE; 
				IF lastpos + 10 < pos THEN 
					Texts.WriteLn(W); Texts.WriteString(W, "  pos");
					Texts.WriteInt(W, pos, 6); Texts.WriteString(W, "  err");
					Texts.WriteInt(W, ABS(n), 4); Texts.Append(Oberon.Log, W.buf);
				END
			END;
			lastpos := pos
		ELSIF n>=0 THEN scanerr:=TRUE
		END 
	END Mark;

	PROCEDURE String(VAR sym: INTEGER);
		VAR i: INTEGER;
	BEGIN i := 0;
		LOOP
			IF ch = 22X THEN EXIT END ;
			IF ch < " " THEN Mark(3); EXIT END ;
			IF i < maxStrLen-1 THEN name[i] := ch; INC(i) ELSE Mark(212); i := 0 END ;
			Texts.Read(R, ch)
		END ;
		Texts.Read(R, ch);
		IF i = 1 THEN sym := 34; numtyp := 1; intval := ORD(name[0]); name[i] := 0X (* ARD *)
		ELSE sym := 36; name[i] := 0X (*string*)
		END
	END String;

	PROCEDURE Identifier(VAR sym: INTEGER);
		VAR i, k: INTEGER;
	BEGIN name[0] := prev; i := 1; k := ORD(prev);
		WHILE (CAP(ch) >= "A") & (CAP(ch) <= "Z") OR (ch >= "0") & (ch <= "9") DO
			IF i < 31 THEN name[i] := ch; INC(i); INC(k, ORD(ch)) END ;
			Texts.Read(R, ch)
		END ;
		name[i] := 0X;
		k := (k+i) MOD KW;	(*hash function*)
		IF (keyTab[k].symb # 0) & (keyTab[k].id = name) THEN sym := keyTab[k].symb
		ELSE k := keyTab[k].alt;
			IF (keyTab[k].symb # 0) & (keyTab[k].id = name) THEN sym := keyTab[k].symb
			ELSE sym := 37 (*ident*)
			END
		END
	END Identifier;
	
	PROCEDURE Hval(ch: CHAR): INTEGER;
		VAR d: INTEGER;
	BEGIN d := ORD(ch) - 30H; (*d >= 0*)
		IF d >= 10 THEN
			IF (d >= 17) & (d < 23) THEN DEC(d, 7) ELSE d := 0; Mark(2) END
		END ;
		RETURN d
	END Hval;

	PROCEDURE Number;
		VAR h, i, j, k, k1, k2, k3, d, e: LONGINT;
					negE: BOOLEAN;
			x, f:	 REAL;
			y, g: LONGREAL;
			lastCh, E: CHAR; neg: BOOLEAN;
			dig: ARRAY maxDig OF CHAR;

	BEGIN dig[0] := prev; i := 1;
		WHILE (CAP(ch) >= "A") & (CAP(ch) <= "Z") OR (ch >= "0") & (ch <= "9") DO
			dig[i] := ch; INC(i); Texts.Read(R, ch)
		END ;
		lastCh := ch; j := 0;
		WHILE (j < i-1) & (dig[j] = "0") & (dig[j+1] # "H")DO INC(j) END ;
		IF ch = "." THEN Texts.Read(R, ch);
			IF ch = "." THEN lastCh := 0X; ch := 7FX END
		END ;
		IF lastCh = "." THEN (*decimal point*)
			h := i;
			WHILE ("0" <= ch) & (ch <= "9") DO (*read fraction*)
				IF i < maxDig THEN dig[i] := ch; INC(i) END ;
				Texts.Read(R, ch)
			END ;

		 (*-------- begin floating-point handling BM 1993.3.10 -----------------------------------*)
			WHILE i MOD 8 # 0 DO dig[i] := "0"; INC(i) END;
			j := 0; k := 0; k1 := 0; k2 := 0; k3 := 0; (* store digits 0..7, 8..15, 16..23, 24..31 in k, k1, k2, k3 *)
			WHILE j < 8 DO k := k*10 + ORD(dig[j]) - ORD("0"); INC(j) END;
			IF 8 < i THEN
				WHILE j < 16 DO k1 := k1*10 + ORD(dig[j]) - ORD("0"); INC(j) END
			END;
			IF 16 < i THEN
				WHILE j < 24 DO k2 := k2*10 + ORD(dig[j]) - ORD("0"); INC(j) END
			END;
			IF 24 < i THEN
				WHILE j < 32 DO k3 := k3*10 + ORD(dig[j]) - ORD("0"); INC(j) END
			END;
			e := 0; E := ch;
			IF (E = "D") OR (E = "E") THEN Texts.Read(R, ch);
				IF ch = "-" THEN negE := TRUE; Texts.Read(R, ch)
				ELSE negE := FALSE;
					IF ch = "+" THEN Texts.Read(R, ch) END
				END;
				WHILE ("0" <= ch) & (ch <= "9") DO
					e := e*10 + ORD(ch) - ORD("0"); Texts.Read(R, ch)
				END;
				IF negE THEN e := - e END
			END;
			y := k3*Reals.Ten(-32) + k2*Reals.Ten(-24); y := y + k1*Reals.Ten(-16);
			IF ABS(e+h) < 308 THEN y := (y + k*Reals.Ten(-8)) / Reals.Ten(-e-h)
			ELSE y := (y + k*Reals.Ten(-8)) * Reals.Ten(h);
				IF (e <= 308-32) OR (e <= 308) & (y < MAX(LONGREAL) / Reals.Ten(e)) THEN y := y * Reals.Ten(e)
					ELSE y := MAX(LONGREAL)
				END
			END;
			neg := FALSE;			(* !!!!!!!!!!!!!!! *)
			IF E = "D" THEN
				IF y = MAX(LONGREAL) THEN y := 0; Mark(203)
					ELSIF neg THEN y := - y
					END;
				IF Reals.ExpoL(y) = 0 THEN y := 0 END;
				numtyp := 4; lrlval := y
			ELSE
				IF MAX(REAL) < y THEN x := 0; Mark(203)
					ELSIF neg THEN x := SHORT(- y)
					ELSE x := SHORT(y)
				END;
				IF Reals.Expo(x) = 0 THEN x:= 0 END;
				numtyp := 3; realval := x
			END
			(*-------- end floating-point handling BM 1993.3.10 -----------------------------------*)

		ELSE (*integer*)
			lastCh := dig[i-1]; intval := 0;
			IF lastCh = "H" THEN
				IF j < i THEN
					DEC(i); intval := Hval(dig[j]); INC(j);
					IF i-j <= 7 THEN
						IF (i-j = 7) & (intval >= 8) THEN DEC(intval, 16) END ;
						WHILE j < i DO intval := Hval(dig[j]) + intval * 10H; INC(j) END
					ELSE Mark(203)
					END
				END
			ELSIF lastCh = "X" THEN
				DEC(i);
				WHILE j < i DO
					intval := Hval(dig[j]) + intval*10H; INC(j);
					IF intval > 0FFH THEN Mark(203); intval := 0 END
				END
			ELSE (*decimal*)
				WHILE j < i DO
					d := ORD(dig[j]) - 30H;
					IF d < 10 THEN
						IF intval <= (MAX(LONGINT) - d) DIV 10 THEN intval := intval*10 + d
						ELSE Mark(203); intval := 0
						END
					ELSE Mark(2); intval := 0
					END ;
					INC(j)
				END
			END ;
			IF lastCh = "X" THEN numtyp := 1 ELSE numtyp := 2 END
		END
	END Number;

	PROCEDURE Get*(VAR sym: INTEGER);
		VAR s: INTEGER;
		
		PROCEDURE Comment;	(* do not read after end of file *)
		BEGIN Texts.Read(R, ch);
			LOOP
				LOOP
					WHILE ch = "(" DO Texts.Read(R, ch);
						IF ch = "*" THEN Comment END
					END ;
					IF ch = "*" THEN Texts.Read(R, ch); EXIT END ;
					IF ch = 0X THEN EXIT END ;
					Texts.Read(R, ch)
				END ;
				IF ch = ")" THEN Texts.Read(R, ch); EXIT END ;
				IF ch = 0X THEN Mark(5); EXIT END
			END
		END Comment;

		PROCEDURE Command; (* << KR *)
			VAR res, i : INTEGER; cmdS: ARRAY 32 OF CHAR; 
		BEGIN
			IF cmd > 0 THEN
				DEC(cmd);
				IF cmd = 0 THEN
					Texts.Read(R, ch);
					 			 WHILE (0X < ch) & (ch <= " ") DO Texts.Read(R, ch) END;
									i := 0; 
					WHILE	(ch > " ") & (ch # "*")	& (i < 31) DO 
						cmdS[i]:= ch; INC(i); Texts.Read(R, ch);
					END; 
					cmdS[i] := 0X;
					Oberon.Call(cmdS, Oberon.Par, FALSE, res);
					IF res # 0 THEN Mark(301) END;
					Comment; 
				END;
			END;
		END Command;
		
		PROCEDURE TestCmd () : BOOLEAN;
			VAR r : Texts.Reader; ch : CHAR;
		BEGIN
			r := R;
			Texts.Read(r, ch);
			IF ch = "$" THEN R := r; sym := 38; (* ; *) cmd := 1 END;
			RETURN ch = "$"
		END TestCmd;

	BEGIN
		Command();
		LOOP (*ignore control characters*)
			IF ch <= " " THEN
				IF ch = 0X THEN ch := " "; EXIT
				ELSE Texts.Read(R, ch)
				END
			(* ELSIF ch > 7FX THEN Texts.Read(R, ch) *)
			ELSE EXIT
			END
		END ;
		prev := ch; Texts.Read(R, ch);
		IF prev <= CHR(07FH) THEN
			CASE prev OF	 (* " " <= prev <= 7FX *)
					" "	: s := 62; ch := 0X (*eof*)
				| "!", "$", "%", "'", "?", "@", "\", "_", "`": s :=	0
				| 22X	: String(s)
				| "#"	: s := 10
				| "&"	: s :=	5
				| "("	:	 IF ch = "*" THEN IF TestCmd() THEN RETURN END; (* << KR *)	Comment; Get(s)	ELSE s := 29	END
				| ")"	: s := 22
				| "*"	: s :=	1
				| "+"	: s :=	6
				| ","	: s := 19
				| "-"	: s :=	7
				| "."	: IF ch = "." THEN Texts.Read(R, ch); s := 21 ELSE s := 18 END
				| "/"	: s := 2
				| "0".."9": Number; s := 34
				| ":"	: IF ch = "=" THEN Texts.Read(R, ch); s := 33 ELSE s := 20 END
				| ";"	: s := 38
				| "<"	: IF ch = "=" THEN Texts.Read(R, ch); s := 12 ELSE s := 11 END
				| "="	: s :=	9
				| ">"	: IF ch = "=" THEN Texts.Read(R, ch); s := 14 ELSE s := 13 END
				| "A".."Z": Identifier(s)
				| "["	: s := 30
				| "]"	: s := 23
				| "^"	: s := 17
				| "a".."z": Identifier(s)
				| "{"	: s := 31
				| "|"	: s := 39
				| "}"	: s := 24
				| "~"	: s := 32
				| 7FX	: s := 21
			END ;
		ELSE
			s := ORD(prev) - 128;
		END;
		sym := s
	END Get;

	PROCEDURE Init*(source: Texts.Text; pos: LONGINT);
	BEGIN
		ch := " "; scanerr := FALSE; lastpos := -8;
		Texts.OpenReader(R, source, pos)
	END Init;

	PROCEDURE EnterKW(sym: INTEGER; name: ARRAY OF CHAR);
		VAR j, k: INTEGER;
	BEGIN j := 0; k := 0;
		REPEAT INC(k, ORD(name[j])); INC(j)
		UNTIL name[j] = 0X;
		k := (k+j) MOD KW;	(*hash function*)
		IF keyTab[k].symb # 0 THEN
			j := k;
			REPEAT INC(k) UNTIL keyTab[k].symb = 0;
			keyTab[j].alt := k
		END ;
		keyTab[k].symb := sym; COPY(name, keyTab[k].id)
	END EnterKW;

BEGIN Texts.OpenWriter(W); i := KW;
	WHILE i > 0 DO
		DEC(i); keyTab[i].symb := 0; keyTab[i].alt := 0
	END ;
	keyTab[0].id := "";
	EnterKW(64, "BY");
	EnterKW(27, "DO");
	EnterKW(44, "IF");
	EnterKW(15, "IN");
	EnterKW(16, "IS");
	EnterKW(25, "OF");
	EnterKW( 8, "OR");
	EnterKW(28, "TO");
	EnterKW(40, "END");
	EnterKW(63, "FOR");
	EnterKW( 4, "MOD");
	EnterKW(35, "NIL");
	EnterKW(58, "VAR");
	EnterKW(45, "CASE");
	EnterKW(41, "ELSE");
	EnterKW(50, "EXIT");
	EnterKW(26, "THEN");
	EnterKW(57, "TYPE");
	EnterKW(49, "WITH");
	EnterKW(52, "ARRAY");
	EnterKW(55, "BEGIN");
	EnterKW(56, "CONST");
	EnterKW(42, "ELSIF");
	EnterKW(60, "IMPORT");
	EnterKW(43, "UNTIL");
	EnterKW(46, "WHILE");
	EnterKW(53, "RECORD");
	EnterKW(47, "REPEAT");
	EnterKW(51, "RETURN");
	EnterKW(54, "POINTER");
	EnterKW(59, "PROCEDURE");
	EnterKW( 3, "DIV");
	EnterKW(48, "LOOP");
	EnterKW(61, "MODULE");
	MarkErrors := TRUE;
END DOCS.