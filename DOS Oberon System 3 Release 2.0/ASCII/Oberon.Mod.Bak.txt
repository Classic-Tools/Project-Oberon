MODULE Oberon; (*JG 28.7.93*)
(* ARD 4. 6. 96 *)

	IMPORT Kernel, Modules, Disk, Display, Input, Objects, Fonts, Streams, SYSTEM;
	(* Display must be before Input for DOS-Oberon. ARD 7. 4. 93 *)
	
	(* Processes, ARD 16.01.95 *)
	(* Tasks eliminated, ARD 02.06.95 *)
	(* Loop eliminated, ARD 17.01.96 *)

	CONST
		(*message ids*)
		defocus = 0; neutralize = 1; mark = 2; (*ControlMsg*)
		consume = 0; track = 1; (*InputMsg*)
		get = 0; set* = 1; reset = 2; (*CaretMsg id/ SelectMsg id*)
		drop = 0; integrate = 1; (*ConsumeMsg id*)
	
		Background = 12;
			
		ActTime = 20;
	
		minint = MIN(INTEGER);	
	
		ESC = 1BX; 
		
		LogWidth = 192;

	TYPE
		ControlMsg = RECORD (Display.FrameMsg)
			id, X, Y: INTEGER
		END;
	
		InputMsg = RECORD (Display.FrameMsg)
			id: INTEGER;
			keys: SET;
			ch: CHAR;
			X, Y: INTEGER;
			fnt: Fonts.Font;
			col, voff: SHORTINT
		END;
	
TYPE KeyboardProc = POINTER TO KeyboardProcDesc;

	VAR
		DW, DH, CL, H0, H1, H2, H3: INTEGER;

		Mod: Modules.Module;
	
		ColTab: ARRAY 256 OF RECORD r, g, b: INTEGER END;
		ScreenOn, Inverted: BOOLEAN;
	
		GCTime, time: LONGINT;
		keys: SET;
		
		keyboard: KeyboardProc;
		
		OptionChar*: CHAR;
		
		cmd: Modules.Command;
		FillerColor: SHORTINT;
		
		log*: Streams.Stream;
		trapped: SHORTINT;
		OriginalBC: Display.MsgProc;

	PROCEDURE NullBC(VAR M: Display.FrameMsg);
	END NullBC;

	(*clocks*)

	PROCEDURE GetClock* (VAR time, date: LONGINT);
	BEGIN Kernel.GetClock(time, date)
	END GetClock;

	PROCEDURE SetClock* (time, date: LONGINT);
	BEGIN Kernel.SetClock(time, date)
	END SetClock;

	PROCEDURE Time* (): LONGINT;
	BEGIN RETURN Input.Time()
	END Time;

	PROCEDURE OpenDisplay* (UW, SW, H: INTEGER);
	BEGIN
		Display.ReplConst(FillerColor, 0, 0, UW + SW, H, 0);
	END OpenDisplay;

	PROCEDURE DisplayWidth* (X: INTEGER): INTEGER;
	BEGIN RETURN DW
	END DisplayWidth;

	PROCEDURE DisplayHeight* (X: INTEGER): INTEGER;
	BEGIN RETURN DH
	END DisplayHeight;

	(*command interpretation*)

	PROCEDURE Call* (name: ARRAY OF CHAR; new: BOOLEAN; VAR res: INTEGER);
		VAR Mod: Modules.Module; P: Modules.Command; i, j: INTEGER; 
	BEGIN res := 1;
		i := 0; j := 0;
		WHILE name[j] # 0X DO
			IF name[j] = "." THEN i := j END;
			INC(j)
		END;
		IF i > 0 THEN
			name[i] := 0X;
			IF new THEN Modules.Free(name, FALSE, res) END;
			Mod := Modules.ThisMod(name, res);
			IF res = 0 THEN
				INC(i); j := i;
				WHILE name[j] # 0X DO name[j - i] := name[j]; INC(j) END;
				name[j - i] := 0X;
				P := Modules.ThisCommand(Mod, name, res);
				IF res = 0 THEN P; res := 0 END
			END
		END
	END Call;

	PROCEDURE Collect*;
	BEGIN GCTime := 0
	END Collect;

	PROCEDURE Quit;
	BEGIN
		Kernel.Reboot(0)
	END Quit;
	
	PROCEDURE SwitchColors;
	VAR i: INTEGER;
	BEGIN
		IF ScreenOn THEN 
			FOR i := 0 TO 255 DO Display.GetColor(i, ColTab[i].r, ColTab[i].g, ColTab[i].b) END;
			FOR i := 0 TO 255 DO Display.SetColor(i, 0, 0, 0) END;
 		ELSE
 			FOR i := 0 TO 255 DO Display.SetColor(i, ColTab[i].r, ColTab[i].g, ColTab[i].b) END;
 		END;
 		ScreenOn := ~ScreenOn
	END SwitchColors;
	
	PROCEDURE ResetColors;
	BEGIN
		Display.SetColor(15, 0, 0, 0); Display.SetColor(1, 255, 0, 0);
		Display.SetColor(2, 0, 255, 0); Display.SetColor(3, 0, 0, 255);
		Display.SetColor(4, 255, 0, 255); Display.SetColor(5, 255, 255, 0);
		Display.SetColor(6, 0, 255, 255); Display.SetColor(7, 170, 0, 0);
		Display.SetColor(8, 0, 153, 0); Display.SetColor(9, 0,	0, 153);
		Display.SetColor(10, 119, 0, 204); Display.SetColor(11, 187, 136, 0);
		Display.SetColor(12, 136, 136, 136); Display.SetColor(13, 190, 190, 190);
		Display.SetColor(14, 221, 221, 221); Display.SetColor(0, 255, 255, 255);
		Inverted := FALSE; ScreenOn := TRUE
	END ResetColors;
	
	PROCEDURE InvColors;
	BEGIN
		IF ~Inverted THEN Display.SetColor(0, 0, 0, 0); Display.SetColor(15, 255, 255, 255); 
		ELSE Display.SetColor(15, 0, 0, 0); Display.SetColor(0, 255, 255, 255) END;
		Inverted := ~Inverted;
	END InvColors;
	
	(* Environment *)
	
	PROCEDURE Handle (VAR M: Objects.ObjMsg);
	VAR X, Y, i, j: INTEGER; keysum: SET; res: INTEGER;
			Mod: Kernel.Module; P: Kernel.Proc; cmd, name: ARRAY 32 OF CHAR;
	BEGIN
		IF M IS InputMsg THEN
			WITH M: InputMsg DO
				IF M.id = track THEN (* no mouse *)
				ELSE (*keyboard input*)
					IF M.ch = "\" THEN Streams.Reset(log); Streams.Write(log, ">")
					ELSIF (M.ch >= "A") & (M.ch <= "Z") OR (M.ch >= "a") & (M.ch <= "z") THEN
						i := 0;
						WHILE M.ch >= " " DO Streams.Write(log, M.ch);
							IF M.ch = "\" THEN IF i > 0 THEN DEC(i) END
							ELSIF i < 31 THEN cmd[i] := M.ch; INC(i) END;
							Input.Read(M.ch)
						END;
						cmd[i] := 0X; i := 0;
						WHILE (cmd[i] # 0X) & (cmd[i] # ".") DO name[i] := cmd[i]; INC(i) END;
						name[i] := 0X; INC(i); Mod := Modules.ThisMod(name, res);
						IF res = 0 THEN j := 0;
							WHILE cmd[i] # 0X DO name[j] := cmd[i]; INC(i); INC(j) END;
							name[j] := 0X;
							P := Modules.ThisCommand(Mod, name, res);
							IF res = 0 THEN P 
							ELSE Streams.Write(log, "~"); Streams.WriteLn(log); Streams.WriteString(log, "Command not found") END
						ELSE Streams.Write(log, "~"); Streams.WriteLn(log); Streams.WriteString(log, "Module not found") END;
						Streams.WriteLn(log); Streams.Write(log, ">")
					END
				END
			END
		END
	END Handle;

	PROCEDURE InitPalette;
	VAR i, r, g, b: INTEGER;
	BEGIN
		IF Display.Depth(0) >= 8 THEN
		i := 16;	r := 0;	g := 130*2;	b := 0;
		WHILE i # 256 DO
			Display.SetColor(i, r DIV 2, g DIV 2, b);
			INC(b, 65);
			IF b > 255 THEN b := 0; INC(g, 65);
				IF g > 511 THEN g := 0; INC(r, 65) END
			END;
			INC(i)
		END
		END;
		Display.SetColor(15, 0, 0, 0); Display.SetColor(1, 255, 0, 0); Display.SetColor(2, 0, 255, 0);
		Display.SetColor(3, 0, 0, 255); Display.SetColor(4, 255, 0, 255); Display.SetColor(5, 255, 255, 0);
		Display.SetColor(6, 0, 255, 255); Display.SetColor(7, 170, 0, 0); Display.SetColor(8, 0, 153, 0);
		Display.SetColor(9, 0, 0, 153); Display.SetColor(10, 119, 0, 204); Display.SetColor(11, 187, 136, 0);
		Display.SetColor(12, 136, 136, 136); Display.SetColor(13, 190, 190, 190);
		Display.SetColor(14, 221, 221, 221); Display.SetColor(0, 255, 255, 255)
	END InitPalette;

	PROCEDURE Init;
	VAR s: ARRAY 8 OF CHAR;
	BEGIN
		Kernel.GetConfig("Colour", s);
		IF s[0] # "0" THEN FillerColor := 12 ELSE FillerColor := 0 END
	END Init;
	
	PROCEDURE ReadNum (VAR pos: LONGINT; VAR i: LONGINT);
		VAR n: LONGINT; s: SHORTINT; x: CHAR;
	BEGIN
		s := 0; n := 0; SYSTEM.GET(pos, x); INC(pos);
		WHILE ORD(x) >= 128 DO INC(n, ASH(ORD(x) - 128, s)); INC(s, 7); SYSTEM.GET(pos, x); INC(pos) END;
		i := n + ASH(ORD(x) MOD 64 - ORD(x) DIV 64 * 64, s)
	END ReadNum;
	
	PROCEDURE Locals(pos, limit: LONGINT; base: LONGINT);
	VAR adr, val: LONGINT;
			sval, form: SHORTINT;
			ch, mode: CHAR;
			ival, i: INTEGER;
			rval: REAL;
			lrval: LONGREAL;
	BEGIN Streams.WriteLn(log); SYSTEM.GET(pos, mode); INC(pos);
		WHILE (pos < limit) & (mode < 0F8X) DO
			SYSTEM.GET(pos, form); INC(pos); ReadNum(pos, adr);
			Streams.WriteString(log, "    ");
			SYSTEM.GET(pos, ch); INC(pos);
			WHILE ch # 0X DO Streams.Write(log, ch); SYSTEM.GET(pos, ch); INC(pos) END;
			Streams.WriteString(log, " = "); INC(adr, base);
			IF mode = 3X THEN SYSTEM.GET(adr, adr) (*indirect*) END;
			CASE form OF
				2: (*BOOL*) SYSTEM.GET(adr, sval);
				IF sval = 0 THEN Streams.WriteString(log, "FALSE")
					ELSE Streams.WriteString(log, "TRUE")
				END
			| 1,3: (*CHAR*) SYSTEM.GET(adr, ch);
				IF (" " <= ch) & (ch <= "~") THEN Streams.Write(log, ch)
					ELSE Streams.WriteHex(log, ORD(ch)); Streams.Write(log, "X")
				END
			| 4: (*SINT*) SYSTEM.GET(adr, sval); Streams.WriteInt(log, sval)
			| 5: (*INT*) SYSTEM.GET(adr, ival); Streams.WriteInt(log, ival)
			| 6: (*LINT*) SYSTEM.GET(adr, val); Streams.WriteInt(log, val)
			| 7: (*REAL*) SYSTEM.GET(adr, rval); Streams.WriteReal(log, rval, 15, 0)
			| 8: (*LREAL*) SYSTEM.GET(adr, lrval); Streams.WriteString(log, "not yet implemented")
			| 9, 13, 14: (*SET, POINTER*)
				SYSTEM.GET(adr, val); Streams.WriteHex(log, val); Streams.Write(log, "H")
			| 15, 17, 18: (*String*) i := 0; Streams.Write(log, 22X);
				LOOP SYSTEM.GET(adr, ch);
					IF (ch < " ") OR (ch >= 90X) OR (i = 64) THEN EXIT END;
					Streams.Write(log, ch); INC(i); INC(adr)
				END;
				Streams.Write(log, 22X)
			END;
			Streams.WriteLn(log); SYSTEM.GET(pos, mode); INC(pos)
		END
	END Locals;

	PROCEDURE Trap*(error, fp, pc, page: LONGINT);	(* exported for Debug *)
	VAR refpos, limit: LONGINT;
			ch, ch0: CHAR;
			X, Y, i: INTEGER;
			mod: Modules.Module;
			procstart, refstart: LONGINT;
			stackorg: LONGINT;
	BEGIN
		SYSTEM.GET(SYSTEM.VAL(LONGINT, Kernel.cur)-36, stackorg);
		IF trapped = 0 THEN trapped := 1;
			OriginalBC := Display.Broadcast; Display.Broadcast := NullBC;
			Display.ResetClip; 
			IF (error > 31) OR ~(error IN {0,6,13,14}) THEN
				SYSTEM.GET(pc-1, ch);
				IF (ch = 0CCX) OR (ch = 0CEX) THEN DEC(pc) END	(* INT 3 OR INTO *)
			END;
			mod := SYSTEM.VAL(Modules.Module, Kernel.GetMod(pc));
			Streams.WriteString(log, "TRAP "); Streams.WriteInt(log, error); Streams.WriteString(log, "  ");
			
			IF error = 0 THEN Streams.WriteString(log, "Division by zero")
			ELSIF error = 4 THEN Streams.WriteString(log, "Overflow")
			ELSIF error = 6 THEN Streams.WriteString(log, "Invalid instruction")
			ELSIF error = 7 THEN Streams.WriteString(log, "Index out of range")
			ELSIF error = 13 THEN Streams.WriteString(log, "General protection fault")
			ELSIF error = 14 THEN
				Streams.WriteString(log, "Page fault at");
				Streams.WriteHex(log, page);	Streams.Write(log, "H");
				IF (page >= 0) & (page < 4096) THEN Streams.WriteString(log, " (NIL reference)")
				ELSIF (page >= 100000H) & (page < Kernel.StackOrg) THEN Streams.WriteString(log, " (Stack overflow)") END
			ELSIF error = 16 THEN
				SYSTEM.GET(pc, ch);
				IF ch = 0CCX THEN Streams.WriteString(log, "Invalid case in CASE statement")
				ELSE Streams.WriteString(log, "Floating-point error") END
			ELSIF error = 17 THEN Streams.WriteString(log, "Function without RETURN")
			ELSIF error = 18 THEN Streams.WriteString(log, "Type guard failed")
			ELSIF error = 19 THEN Streams.WriteString(log, "Type test failed")	(* VAR parameter *)
			ELSIF error = 20 THEN Streams.WriteString(log, "ASSERT failed")
			ELSIF error = 21 THEN Streams.WriteString(log, "Bad sector number")
			ELSIF error = 22 THEN Streams.WriteString(log, "Disk full")
			ELSIF error = 24 THEN Streams.WriteString(log, "Keyboard interrupt")
			ELSIF error = 26 THEN Streams.WriteString(log, "Out of memory")
			END; 
			Streams.WriteLn(log);
			
			WHILE (fp < stackorg) & (mod = NIL) DO
				Streams.WriteString(log, "Unknown module  PC =");	Streams.WriteHex(log, pc);
				Streams.WriteString(log, "H  FP =");	Streams.WriteHex(log, fp);
				Streams.WriteLn(log);
				SYSTEM.GET(fp+4, pc); SYSTEM.GET(fp, fp);
				mod:=SYSTEM.VAL(Modules.Module, Kernel.GetMod(pc))
			END;
			
			LOOP 
				IF mod = NIL THEN EXIT END;
				Streams.WriteString(log, mod.name);
				IF mod.refs # NIL THEN
					refpos := SYSTEM.ADR(mod.refs[0]);
					limit := refpos + LEN(mod.refs^);
					LOOP SYSTEM.GET(refpos, ch); INC(refpos);
						IF refpos >= limit THEN EXIT END;
						IF ch = 0F8X THEN (*start proc*)
							ReadNum(refpos, procstart);
							IF pc < SYSTEM.ADR(mod.code[0]) + procstart THEN
								EXIT
							END;
							refstart := refpos;
						 REPEAT SYSTEM.GET(refpos, ch); INC(refpos) UNTIL ch = 0X; (*skip name*)
						ELSIF ch < 0F8X THEN (*skip object*)
							INC(refpos);	(* skip typeform *)
							ReadNum(refpos, procstart);	(* skip offset *)
							REPEAT SYSTEM.GET(refpos, ch); INC(refpos) UNTIL ch = 0X; (*skip name*)
						END
					END;
					refpos := refstart;
					Streams.Write(log, "."); SYSTEM.GET(refpos, ch); INC(refpos); ch0 := ch;
					WHILE ch # 0X DO Streams.Write(log, ch); SYSTEM.GET(refpos, ch); INC(refpos) END;
					Streams.WriteString(log, "  PC ="); Streams.WriteInt(log, pc-SYSTEM.ADR(mod.code[0]));
					IF ch0 = "$" THEN Locals(refpos, limit, mod.sb) ELSE Locals(refpos, limit, fp) END
				ELSE Streams.WriteString(log, "  PC ="); Streams.WriteInt(log, pc-SYSTEM.ADR(mod.code[0]));
					Streams.WriteLn(log)
				END;
				SYSTEM.GET(fp+4, pc); SYSTEM.GET(fp, fp); (* return addr from stack *)
				IF fp >= stackorg THEN EXIT END; (* not called from stack *)
				mod:=SYSTEM.VAL(Modules.Module, Kernel.GetMod(pc))
			END; (*LOOP*)
		ELSIF trapped = 1 THEN trapped := 2;
			Streams.WriteLn(log);
			Streams.WriteString(log, "REC TRAP "); Streams.WriteInt(log, error);
			Streams.WriteLn(log); 
	ELSE (* skip *)
		END;
		Display.Broadcast := OriginalBC; trapped := 0
	END Trap;
	
	PROCEDURE ShowModules*;
	VAR size: LONGINT;
			M: Modules.Module;
	BEGIN 
		M := Kernel.modules;
		WHILE M # NIL DO
			size := SIZE(LONGINT) * (LEN(M.varEntries^)+LEN(M.entries^)+LEN(M.ptrTab^)+
				LEN(M.tdescs^)+LEN(M.imports^)) + SIZE(Kernel.Cmd)*LEN(M.cmds^) + 
				LEN(M.data^)+LEN(M.code^);
			IF M.refs # NIL THEN INC(size, LEN(M.refs^)) END;
			Streams.WriteLn(log); 
			Streams.WriteString(log, M.name); Streams.Write(log, " "); Streams.WriteInt(log, size); Streams.Write(log, " "); 
			Streams.WriteInt(log, M.refcnt); 
			M := M.next
		END;
	END ShowModules;

	PROCEDURE Watch*;
	BEGIN
		Streams.WriteLn(log); 
		Streams.WriteString(log, "memory: "); Streams.WriteInt(log, Kernel.Available());
		Streams.WriteString(log, " bytes"); Streams.WriteLn(log);
		Streams.WriteString(log, "largest block: "); Streams.WriteInt(log, Kernel.LargestAvailable());
		Streams.WriteString(log, " bytes"); Streams.WriteLn(log);
		Streams.WriteString(log, "disk space: "); Streams.WriteInt(log, Disk.Available()*Disk.SectorSize DIV 1024);
		Streams.WriteString(log, "k bytes"); 
	END Watch;
	
	PROCEDURE Reset*;
	BEGIN
		Streams.right := Display.Width - LogWidth;
		Display.ReplConst(FillerColor, 0, 0, Streams.right, Display.Height, 0);
	END Reset;
	
	TYPE KeyboardProcDesc = RECORD (PROTECTED)
	VAR N: ControlMsg; M: InputMsg; ch: CHAR;
	BEGIN {PARALLEL(3), SAFE}
		LOOP
			Input.Read(ch); (* suspends until ch available *)
			IF ch = ESC THEN Reset (*N.F := NIL; N.id := neutralize; Display.Broadcast(N)*)
			ELSIF ch = 0FFX THEN Quit
			ELSIF ch = 0FCX THEN SwitchColors
			ELSIF ch = 0FDX THEN ResetColors
			ELSIF ch = 0FEX THEN InvColors
			ELSE M.F := NIL; M.id := consume; M.ch := ch; M.fnt := Fonts.Default; M.col := Display.FG; M.voff := 0; 
				Handle(M);
			END;
			DEC(GCTime); 
			IF GCTime <= 0 THEN GCTime := ActTime; ACTIVATE(Kernel.garbage) END;
		END
	END KeyboardProcDesc;
		
BEGIN 
	Init;
	OptionChar := "\";

	DW := Display.Width; DH := Display.Height; CL := Display.ColLeft;
	H3 := DH - DH DIV 3;
	H2 := H3 - H3 DIV 2;
	H1 := DH DIV 5;
	H0 := DH DIV 10;
	
	GCTime := ActTime;
	OpenDisplay(DW DIV 8 * 5, DW DIV 8 * 3, DH);
	Display.SetMode(0, {});
	Fonts.Default := Fonts.This("Oberon10.Scn.Fnt");
	ScreenOn := TRUE; Inverted := FALSE;
	NEW(keyboard);
(*	SYSTEM.PUT(SYSTEM.VAL(LONGINT, keyboard)-16, TRUE); (* Strongly kernel-dependent !!! *)*)
	InitPalette; 
	Kernel.GCenabled := TRUE; 
	
	Streams.Init;
	log := Streams.New("Log", LogWidth);
	
	Kernel.InstallTrap(Trap); 
	
	Streams.WriteString(log, "Active Oberon System"); Streams.WriteLn(log);
	Streams.WriteString(log, "Version 2.11  11.9.96"); Streams.WriteLn(log);
	Streams.Write(log, ">");
END Oberon.