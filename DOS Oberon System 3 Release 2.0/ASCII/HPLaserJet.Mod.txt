MODULE Printer; (*	<><> High-Tech-Center	<><>
	<< HP Laserjet	Printer interface for MS-DOS Oberon System	>>
	
	Version: 1.1 
 
	Author:	L. Truszek	
	Date:	15-JAN-93	
	Last update: 06-08-93 
	
	How it works :
						This interface uses the Oberon "SyntaxXX.Pr3.Fnt" printer files and
						converts to temporary HP font descriptors and loads

	Used manual :	
						PHILIPS NMS 1481 
						Technical reference manual
						HP LaserJet Series II Laserprinter emulation mode 

	Printer Language used :
						HP-PCL 
						
		*)

	IMPORT SYSTEM, Files, Objects, V24, Oberon, Fonts, Texts, Centronics;

	CONST
			(* The maximal logical HP Laserjet	page size for A4 format *)

			HPPageWidth = 2338;	
			HPPageHeight = 3390;	
			maxfonts = 14 ;
			BaseFont = 100 ; (* starting number for HP font id-s *)
			N = 40;
	

		(* spacing *)
			PROPOR = 1; (* proportional *)
			FIXEDSP = 0; (* fixed *)

		(* orientation *)
			PORTRAIT = 0; (* portrait	*)
			LANDSCP = 1; (* landscape *)

			ESC = 01BX;
			FF = 0CX;
			
		(* compatibility *)
			PW = 2336; PH = 3281; PL = PW DIV 32;
			CH = PH DIV 4;
			
	(* Character descriptor for HP Laserjet Printer *)

 TYPE
		Bitmap = POINTER TO ARRAY CH, PL OF SET;
		Pattern = ARRAY 16 OF SET;
		Fontx = Fonts.Font; 
		
		RealVector = ARRAY N OF REAL;
		Poly = RECORD a, b, c, d, t: REAL END ;
		PolyVector = ARRAY N OF Poly;

		Set = LONGINT;
		WriteProc = PROCEDURE (port: INTEGER; ch: CHAR);

		Font = RECORD 
						name: ARRAY 32 OF CHAR;
						pitch: SHORTINT;
						chartab: Set;	(* ARRAY 256 OF BIT *)
					END;

		HPFontDesc = RECORD	(* the HP font descriptor *)
								size: INTEGER;
								res0: SHORTINT;
								type: SHORTINT;
								res1, 
								base,
								cellwidth,
								cellheight: INTEGER;
								orient: SHORTINT;
								space: SHORTINT;
								symbol,
								pitch,
								height,
								xheight: INTEGER;
								widthtype,style*,
								strokeweight,typeface, 
								res2 ,serifstyle: SHORTINT;
								res3: INTEGER;
								underdist,underheight: SHORTINT;
								textheight, 
								textwidth, 
								res4,res5: INTEGER;
								pitchext,heightext :SHORTINT;
								res6,res7,res8 :INTEGER;
								name: ARRAY 16 OF CHAR;
					END;

	(* the HP Character descriptor *)

		HPCharDesc= RECORD
								fix1,fix2,
								orient,
								left,
								top,
								width,
								height,
								delta: INTEGER;
							END;

		Bits = POINTER TO BitsDesc;
		BitsDesc = ARRAY MAX(INTEGER) OF SET;

	VAR
		res*: INTEGER;
		Width*, Height*, Depth*: INTEGER;
		FrameX*, FrameY*, FrameW*, FrameH*: INTEGER;
		Unit*: LONGINT;
		Write: WriteProc;
		TmpWrite, FileWrite: WriteProc;

		CurFont, PrevFont :SHORTINT;

		M: POINTER TO ARRAY HPPageHeight OF Set;
		maxX, maxY, minX, minY: INTEGER;

		PrintDevice: ARRAY 32 OF CHAR;

		TMP: Files.Rider;
		tmp: Files.File;
		
		nofonts: INTEGER;
		font: POINTER TO ARRAY maxfonts OF Font;

		R: Files.Rider;
		f: Files.File;		(* file for output *)
		new: BOOLEAN;
		port: INTEGER;
		ukg: PROCEDURE;
		
	PROCEDURE OpenSerial(p: INTEGER);
	BEGIN
		IF p = 2 THEN port := V24.COM2 ELSE port := V24.COM1 END;
		V24.Start(port, V24.WL8,V24.STOP1,V24.ODDPAR,V24.BPS9600);
		Write := V24.Send;
	END OpenSerial;

	PROCEDURE OpenParallel( c: INTEGER);
	BEGIN
		IF c = 2 THEN port := Centronics.LPT2 ELSE port := Centronics.LPT1 END;
		Write := Centronics.Send;
		Centronics.Start(port);
	END OpenParallel;

	PROCEDURE OpenFile(name: ARRAY OF CHAR);
	BEGIN
		f := Files.Old(name); new := FALSE;
		IF f = NIL THEN f := Files.New(name); new := TRUE END;	
		Files.Set(R,f,Files.Length(f));
		Write := FileWrite;	
	END OpenFile;

	PROCEDURE open(name: ARRAY OF CHAR);
	BEGIN
		res := 0;
		f := NIL; 
		IF name = "LPT1" THEN OpenParallel(1)	
		ELSIF name = "LPT2" THEN OpenParallel(2) 
		ELSIF name = "COM1" THEN OpenSerial(1) 
		ELSIF name = "COM2" THEN OpenSerial(2) 
		ELSE OpenFile("Document.Print") END;
	END open;

	PROCEDURE close;
	BEGIN
		IF f # NIL THEN
			IF new THEN Files.Register(f) ELSE Files.Close(f) END;
		END;
		f := NIL;
		res := -1;
	END close;
 

(* Font table procedures *)

	PROCEDURE LookupFont(name: ARRAY OF CHAR; VAR i: SHORTINT; VAR inserted: BOOLEAN);
	BEGIN 
		inserted := FALSE;
		i := 0;
		WHILE (i < nofonts) & (font[i].name # name) DO INC(i) END ;
		IF i = nofonts THEN
			IF nofonts < maxfonts THEN
				COPY(name,font[i].name);	
				INC(nofonts);
				inserted := TRUE;
			ELSE i := maxfonts		(* table full *)
			END
		END ;
	END LookupFont;
	
(* Set procedures *)

	PROCEDURE New(VAR s: Set; len: INTEGER);
	VAR i,size: INTEGER; b: Bits;
	BEGIN (* Init *)
		size := (len + 31) DIV 32;	(* size in SET elements *)
		SYSTEM.NEW(b,size * 4 ); (* size in bytes *)
		i:= 0;
		WHILE i < size DO b[i] := {}; INC(i) END;
		s := SYSTEM.VAL(LONGINT,b);
	END New;
	
	PROCEDURE Incl(s: Set; e1: INTEGER);
	VAR b: Bits;
	BEGIN (* Incl *)
		b:= SYSTEM.VAL(Bits,s);
		INCL(b^[e1 DIV 32], e1 MOD 32);
	END Incl;

	PROCEDURE In(s: Set; e1: INTEGER): BOOLEAN;
	VAR b: Bits;
	BEGIN (* In *)
		b:= SYSTEM.VAL(Bits,s);
		RETURN e1 MOD 32 IN b^[e1 DIV 32]
	END In;
		
 (* Swap bytes in INTEGER *)

	PROCEDURE SB ( i: INTEGER): INTEGER;
	VAR iadr, nadr: LONGINT;
			n: INTEGER;
			b0,b1: CHAR;
	BEGIN
		iadr := SYSTEM.ADR(i);
		nadr := SYSTEM.ADR(n);
		SYSTEM.GET(iadr,b0);
		SYSTEM.GET(iadr+1,b1);
		SYSTEM.PUT(nadr,b1);
		SYSTEM.PUT(nadr+1,b0);
		RETURN n;
	END SB;
	
	PROCEDURE WriteString(VAR s: ARRAY OF CHAR);
	VAR i: INTEGER;
	BEGIN
		i:= 0;
		WHILE s[i] # 0X DO Write(port, s[i]); INC(i) END;
	END WriteString;

	PROCEDURE WriteInt(x: INTEGER);
	VAR i: INTEGER;
			xx: LONGINT;
			s: ARRAY 7 OF CHAR;
	BEGIN
		i:= 0;	
		xx := ABS(x);
		REPEAT
			s[i] := CHR(xx MOD 10 + ORD("0"));
			INC(i);
			xx := xx DIV 10;
		UNTIL xx = 0;
		IF x < 0 THEN s[i] := "-"; INC(i) END;
		REPEAT DEC(i); Write(port, s[i]) UNTIL i = 0;
	END WriteInt;

	PROCEDURE Pos (x,y: INTEGER);
	BEGIN
		y := Height - y;
		Write(port, ESC);Write(port, "*");Write(port, "p");WriteInt(x);Write(port, "x");
		WriteInt(y);Write(port, "Y"); 
	END Pos;


	PROCEDURE SetRes(res:INTEGER);
	BEGIN
 		Write(port, ESC); Write(port, "*");Write(port, "t");WriteInt(res);
 		Write(port, "R");
	END SetRes;

	PROCEDURE Block(w,h: INTEGER);
	BEGIN
		IF (w = 1) & (h =1 )	THEN	(* it's only a dot , execute dot macro *)
			Write(port, ESC);Write(port, "&");Write(port, "f");Write(port, "1");Write(port, "y");
			Write(port, "&");Write(port, "f");Write(port, "2");Write(port, "X");
		ELSE
			Write(port, ESC); Write(port, "*");Write(port, "c");
			WriteInt(w);Write(port, "a");WriteInt(h);Write(port, "b");
			Write(port, "1");Write(port, "0");Write(port, "0");Write(port, "g"); (* 100 % rule pattern *)
			Write(port, "2");Write(port, "P");
		END;
	END Block;

	PROCEDURE definedot;	(* define macro for one dot *)
	BEGIN
		Write(port, ESC);Write(port, "&");Write(port, "f");Write(port, "1");Write(port, "y");
		Write(port, "&");Write(port, "f");Write(port, "0");Write(port, "X");	(* start macro *)
	 
		Write(port, ESC); Write(port, "*");Write(port, "c");	(* define block 1x1 *)
		Write(port, "1");Write(port, "a");Write(port, "1");Write(port, "b");
		Write(port, "1");Write(port, "0");Write(port, "0");Write(port, "g"); (* 100 % rule pattern *)
		Write(port, "2");Write(port, "P");
	
		(* end macro *)
		Write(port, ESC);Write(port, "&");Write(port, "f");Write(port, "1");Write(port, "X") ;
	END definedot;
	
	PROCEDURE dot;		(* execute dot macro *)
	BEGIN
		Write(port, ESC);Write(port, "&");Write(port, "f");Write(port, "1");Write(port, "y");
		Write(port, "&");Write(port, "f");Write(port, "2");Write(port, "X");
	END dot;

	PROCEDURE PutRaster(len: INTEGER ; VAR r: ARRAY OF CHAR);
	VAR i: INTEGER;
	BEGIN
		Write(port, ESC); Write(port, "*");Write(port, "r");
		Write(port, "1"); Write(port, "A");
		Write(port, ESC);Write(port, "*");Write(port, "b");WriteInt(len);
		Write(port, "W");
		i := 0;
		WHILE i < len DO Write(port, r[i]); INC(i) END;
		Write(port, ESC);Write(port, "*");Write(port, "r");Write(port, "B");
	END PutRaster;

	PROCEDURE InitPage;
	VAR y: INTEGER;
	BEGIN
	NEW(M);	
		y :=0;
		WHILE y < Height DO M[y] := SYSTEM.VAL(LONGINT,NIL); INC(y) END;
		maxX := MIN(INTEGER);
		maxY := MIN(INTEGER);
		minX := MAX(INTEGER);
		minY	:= MAX(INTEGER);
	END InitPage;

	PROCEDURE ClosePage;
	VAR k,j,l,x,y,t,i: INTEGER;
	BEGIN
		IF M = NIL THEN RETURN END;
		y := minY;
		WHILE y <= maxY DO
			IF SYSTEM.VAL(Bits,M[y]) # NIL THEN
				j := minX;
				WHILE j <= maxX DO
					WHILE (j <= maxX) & ~ In(M[y],j) DO INC(j) END;
					l := 0; x:= j;
					WHILE (j <= maxX) & In(M[y],j) DO INC(l); INC(j) END;
					IF l > 0 THEN Pos(x,y); Block(l,1) END;
				END;
				M[y] := SYSTEM.VAL(LONGINT, NIL);	(* Clear *)
			END;
			INC(y);
		END;
		maxX := MIN(INTEGER);
		maxY := MIN(INTEGER);
		minX := MAX(INTEGER);
		minY	:= MAX(INTEGER);
	END ClosePage;

	(* Reverse bits in CHAR variable *)
	PROCEDURE Reverse(VAR c: CHAR); (* reverse bits in BYTE *)
	VAR ib,ob: SET;
			ip,op: INTEGER;
	BEGIN
		ib := SYSTEM.VAL(SET,c);
		ip := 0; op := 7; ob := {};
		WHILE ip < 8 DO
			IF ip IN ib THEN INCL(ob,op) END;
			INC(ip);DEC(op);
		END;
		c := SYSTEM.VAL(CHAR,ob);
	END Reverse;
	
	PROCEDURE CreateFontDesc(id, base, cw, ch, or, sp, pi, he: INTEGER; name: ARRAY OF CHAR);
	VAR i: INTEGER;
			a: LONGINT;
			x: CHAR;
			fd: HPFontDesc;
			fdlen: INTEGER;
	BEGIN
		fdlen := SIZE(HPFontDesc);
		Write(port, ESC); Write(port, "*"); Write(port, "c"); WriteInt(id); Write(port, "D");
		Write(port, ESC); Write(port, "*"); Write(port, "c"); Write(port, "4"); Write(port, "F"); 
		(* temporary font *)
	
		Write(port, ESC); Write(port, ")"); Write(port, "s"); WriteInt(fdlen); Write(port, "W");
	
		(* fill the descriptor with zeros *)
		i:= 0;
		a := SYSTEM.VAL(LONGINT,SYSTEM.ADR(fd));
		WHILE i < fdlen DO SYSTEM.PUT(a,0X); INC(a); INC(i) END;
	
		fd.size := SB(fdlen);
		fd.type := 2; (* any character *)
		fd.base := SB( base) ;	
		fd.cellwidth := SB(cw) ; 
		fd.cellheight := SB( ch);	
		fd.orient := SHORT(or);
		fd.space := SHORT(sp);
		fd.symbol := SB((10 * 32 + ORD("U") - 64)); (* 10U *)
		fd.pitch := SB( pi * 4 ); 
		fd.height := SB( 4 * he); 
		fd.typeface := 5; 
		
		(* copy the font name *)
		i:= 0;
		WHILE (i < LEN(name)) & (i < LEN(fd.name)) DO fd.name[i] := name[i]; INC(i) END;
		
		(* copy	the descriptor to file *)
		i:= 0;
		a := SYSTEM.VAL(LONGINT,SYSTEM.ADR(fd));
		WHILE i < fdlen DO
			SYSTEM.GET(a,x); INC(a); 
			Write(port, x);
			INC(i);
		END;
	END CreateFontDesc;

 (* define one character for LaserJet *)
 
	PROCEDURE DownloadChar(fnt: Fonts.Font;ch:CHAR; num: INTEGER);
	CONST maxpat = 256;
	TYPE Pattern = POINTER TO PatternDesc;
			PatternDesc = RECORD 
										w, h: SHORTINT;
										raster: ARRAY (maxpat+7) DIV 8 * maxpat OF CHAR;
									END;
	VAR hdr: HPCharDesc;
			size,i,hdrlen: INTEGER;
			dx, x, y, w, h: INTEGER;
			pat, a: LONGINT;
			c: CHAR;
			p: Pattern;
			j, k, l: INTEGER;
		(* reverse bits inchar *)
	BEGIN
		hdrlen := SIZE (HPCharDesc);
		(* Get char definition *)
		Fonts.GetChar(fnt,ch,dx,x,y,w,h,pat);
		
		IF (dx = 0) OR (w= 0) THEN (* no valid size - no action *) RETURN END; 
		
		(* create char descriptor for HP *)
		hdr.fix1 := 4 ;					(*	4, 0	*)
		hdr.fix2:= 256 * 1 + 14;	(*	14,1 *)
		hdr.orient := 0; 
		hdr.left := SB(x);	
		hdr.top := SB (h+y); 
		hdr.width := SB ( w) ;
		hdr.height := SB( h);
		hdr.delta := SB( 4* dx) ;	(* multiple of 4 must be *)
		
		(* write commands	for HP *)
		size := (( w+7) DIV 8) * h ;	(* pattern size *)
		Write(port, ESC); Write(port, "*"); Write(port, "c"); WriteInt(num);Write(port, "E");
		Write(port, ESC); Write(port, "("); Write(port, "s"); WriteInt(size+hdrlen); Write(port, "W");
		a := SYSTEM.ADR(hdr);
		i:= 0 ;
		WHILE i < hdrlen DO		(* write char descriptor *)
			SYSTEM.GET(a,c);INC(a);
			Write(port, c);
			INC(i);
		END ;
		(* write raster data in reverse mode *)
		p := SYSTEM.VAL(Pattern,pat);
		l :=(w+7) DIV 8;
		j := size - l;
		WHILE j >= 0 DO 
			k := 0;
			WHILE k < l DO
				c := p.raster[j+k]; Reverse(c);
				Write(port, c);
				INC(k);
			END;
			DEC(j,l);
		END;
	END DownloadChar;

	PROCEDURE SwitchOn(fntno :SHORTINT);
	BEGIN
		Write(port, ESC);Write(port, "(");WriteInt(BaseFont+fntno); Write(port, "X"); 
	END SwitchOn;

	PROCEDURE CreateFont (fnt: Fonts.Font; fntno, pitch, orient, spacing: INTEGER);
	VAR ch: CHAR;
			i: INTEGER;
	BEGIN
		(* create font descriptor for new font arrived *)
		CreateFontDesc(fntno, fnt.maxY, (* baseline *)
								fnt.maxX-fnt.minX,	(* cell with *)
								fnt.maxY-fnt.minY,		(* cell height *)
								orient,						(* orientation, potrait*)
								spacing,						(* spacing, proportionel *)
								pitch,
								fnt.height,					(* height *)
								fnt.name);
	END CreateFont;

	PROCEDURE SetFont(name: ARRAY OF CHAR; VAR s : ARRAY OF CHAR);
	VAR fnt: Fonts.Font;
			ch, fnttype: CHAR;
			i, id: INTEGER;
			fntno,pitch: SHORTINT;
			inserted: BOOLEAN;

		PROCEDURE ToPr3Font(VAR fn: ARRAY OF CHAR; VAR pi: SHORTINT);
		VAR i: INTEGER;
				ch,ch2,ch3: CHAR;
		BEGIN
			i:= 0;
			ch := fn[i];
			WHILE ((ch < "0") OR (ch > "9")) & (ch # ".") & (ch # 0X) DO INC(i); ch := fn[i] END;
			IF (ch = ".") OR (ch = 0X) THEN pi := 0;
			ELSE
				pi := SHORT(ORD(ch) - ORD("0")) ;
				INC(i); ch := fn[i];
				IF (ch >= "0") & (ch <= "9") THEN
					pi := SHORT (10* pi + (ORD(ch)- ORD("0")));
					INC(i);ch := fn[i];
				END;
				IF ch # "." THEN INC(i) END;
			END;
			(* convert "*.Scn.*" filename to "*.Pr3.*" file name *)
			ch := fn[i+1];
			ch2 := fn[i+2];
			ch3 := fn[i+3];
			IF (ch = "S") & (ch2 = "c") & (ch3= "n") THEN fn[i+1] := "P"; fn[i+2] := "r"; fn[i+3] := "3" END;
		END ToPr3Font;

	BEGIN
		ToPr3Font(name,pitch);			(* convert name to Printer file name *)
		
		IF (Files.Old(name) = NIL) THEN (* no such file *)
			COPY ("Syntax10.Pr3.Fnt",name); (* default printer font *);
		END;
		LookupFont(name,fntno,inserted); (* lookup in own font table *)
		IF inserted THEN	(* if new font then init*)
			font[fntno].pitch := pitch; 
			New(font[fntno].chartab,256);
			i := 0;
			WHILE s[i] # 0X DO	(* set the used chars in this font *)
				Incl(font[fntno].chartab,ORD(s[i]));
				INC(i);
			END;
		ELSIF fntno < maxfonts THEN	(* found *)
			i := 0;
			WHILE s[i] # 0X DO	(* set used characters inside the font *)
				Incl(font[fntno].chartab,ORD(s[i])) ;
				INC(i);
			END;
		ELSE (* table full*) END;
		PrevFont :=CurFont;
		CurFont := fntno;
		IF CurFont # PrevFont THEN	(* change font if it needed *)
			SwitchOn(fntno);
		END;
	END SetFont;

	PROCEDURE LoadFont( f: SHORTINT); (* load used font with used chars *)
	VAR i: INTEGER;
	BEGIN
		CreateFont(Fonts.This(font[f].name),BaseFont+f,font[f].pitch,PORTRAIT,PROPOR);
		i:= 0;
		WHILE i < 256 DO
			IF In(font[f].chartab,i) THEN DownloadChar(Fonts.This(font[f].name), CHR(i), i) END;
			INC(i);
		END;
	END LoadFont;
 
	PROCEDURE Dot(x,y: INTEGER);
	BEGIN
		IF M = NIL THEN	(* the first graphic usage *)	InitPage END;
		IF SYSTEM.VAL(Bits,M[y]) = NIL THEN New(M[y], Width) END;
		Incl(M[y],x);
		IF x > maxX THEN maxX := x END;
		IF y > maxY THEN maxY := y END;
		IF x < minX THEN minX := x END;
		IF y < minY THEN minY := y END;
	END Dot;

	PROCEDURE line(x0, y0, x1, y1: INTEGER);
	VAR x, y, dx, dy, d, inc: INTEGER;
	BEGIN
		IF y1 - y0 < x0 - x1 THEN 
			x := x0; 
			x0 := x1; x1 := x; y := y0; 
			y0 := y1; y1 := y 
		END;
		dx := 2 * (x1 - x0);
		dy := 2 * (y1 - y0);
		x := x0; y := y0; inc := 1;
		IF dy > dx THEN
			d := dy DIV 2;
			IF dx < 0 THEN inc := -1; dx := -dx END;
			WHILE y <= y1 DO
				Dot(x, y);
				INC(y); DEC(d, dx);
				IF d < 0 THEN INC(d, dy); INC(x, inc) END
			END
		ELSE
			d := dx DIV 2;
			IF dy < 0 THEN inc := -1; dy := -dy END;
			WHILE x <= x1 DO
				Dot( x, y);
				INC(x); DEC(d, dy);
				IF d < 0 THEN INC(d, dx); INC(y, inc) END
			END
		END
	END line;

	PROCEDURE circle (x0, y0, r: INTEGER);
	VAR x, y, q: INTEGER;
	BEGIN
		x := 0; y := r; q := r;
		WHILE x <= y DO
			Dot( x0 + x, y0 + y); Dot( x0 + y, y0 + x);
			Dot( x0 - x, y0 + y); Dot( x0 - y, y0 + x);
			Dot( x0 + x, y0 - y); Dot( x0 + y, y0 - x);
			Dot( x0 - x, y0 - y); Dot( x0 - y, y0 - x);
			INC(x); DEC(q, 2 * x - 1);
			IF q <= 0 THEN DEC(y); INC(q, 2 * y) END
		END
	END circle;

	PROCEDURE ellipse(x0, y0, a, b: INTEGER);
	VAR a2, b2, ex, ey, q: LONGINT; x, y: INTEGER;
	BEGIN
		IF (a <= 800) & (b <= 800) THEN (* longint range guard *)
			a2 := LONG(a) * a; b2 := LONG(b) * b;
			ex := b2; ey := a2 * (b * 2 - 1); q := 0;
			a2 := a2 * 2; b2 := b2 * 2;
			x := 0; y := b;
			WHILE ey > ex DO
				Dot( x0 + x, y0 + y); Dot( x0 - x, y0 + y);
				Dot( x0 + x, y0 - y); Dot( x0 - x, y0 - y);
				INC(x); INC(q, 2 * ex); INC(ex, b2);
				IF q > ey THEN DEC(y); DEC(q, 2 * ey); DEC(ey, a2) END
			END;
			WHILE y >= 0 DO
				Dot( x0 + x, y0 + y); Dot( x0 - x, y0 + y);
				Dot( x0 + x, y0 - y); Dot( x0 - x, y0 - y);
				DEC(y); DEC(q, 2 * ey); DEC(ey, a2);
				IF q < -ex THEN INC(x); INC(q, 2 * ex); INC(ex, b2) END
			END
		END
	END ellipse;

	PROCEDURE PrintPoly(x0, y0: INTEGER; VAR p, q: Poly; lim: REAL);
	VAR t: REAL; x, y: LONGINT;
	BEGIN t := 0;
		REPEAT
			Dot(SHORT(ENTIER(((p.a * t + p.b) * t + p.c) * t + p.d) + x0),SHORT(ENTIER(((q.a * t + q.b) * t + q.c) * t + q.d) + y0));
			t := t + 1.0
		UNTIL t >= lim
	END PrintPoly;

	PROCEDURE SolveTriDiag(VAR a, b, c, y: RealVector; n: INTEGER);
	VAR i: INTEGER;
			r: REAL;
	BEGIN (*a, b, c of tri-diag matrix T; solve Ty' = y for y', assign y' to y*)
		i := 1;
		WHILE i < n DO 
			r := y[i];
			r :=r - c[i-1]*y[i-1]; 
			y[i] := r;
			INC(i) 
		END ;
		i := n-1; y[i] := y[i]/a[i];
		WHILE i > 0 DO 
			DEC(i); r := y[i];
			r := (r- b[i]*y[i+1])/a[i] ;
			y[i] := r;
		END
	END SolveTriDiag;	

	PROCEDURE OpenSpline(VAR x, y, d: RealVector; n: INTEGER);
	VAR i: INTEGER; d1, d2: REAL;
			a, b, c: RealVector;
	BEGIN (*from x, y compute d = y'*)
		b[0] := 1.0/(x[1] - x[0]); a[0] := 2.0*b[0]; c[0] := b[0];
		d1 := (y[1] - y[0])*3.0*b[0]*b[0]; d[0] := d1; i := 1;
		WHILE i < n-1 DO
			b[i] := 1.0/(x[i+1] - x[i]);
			a[i] := 2.0*(c[i-1] + b[i]);
			c[i] := b[i];
			d2 := (y[i+1] - y[i])*3.0*b[i]*b[i];
			d[i] := d1 + d2; d1 := d2; INC(i)
		END ;
		a[i] := 2.0*b[i-1]; d[i] := d1; i := 0;
		WHILE i < n-1 DO c[i] := c[i]/a[i]; a[i+1] := a[i+1] - c[i]*b[i]; INC(i) END ;
		SolveTriDiag(a, b, c, d, n)
	END OpenSpline;

	PROCEDURE ClosedSpline(VAR x, y, d: RealVector; n: INTEGER);
	VAR i: INTEGER; d1, d2, hn, dn,r: REAL;
			a, b, c, w: RealVector;
	BEGIN (*from x, y compute d = y'*)
		hn := 1.0/(x[n-1] - x[n-2]);
		dn := (y[n-1] - y[n-2])*3.0*hn*hn;
		b[0] := 1.0/(x[1] - x[0]);
		a[0] := 2.0*b[0] + hn;
		c[0] := b[0];
		d1 := (y[1] - y[0])*3.0*b[0]*b[0]; d[0] := dn + d1;
		w[0] := 1.0; i := 1;
		WHILE i < n-2 DO
			b[i] := 1.0/(x[i+1] - x[i]);
			a[i] := 2.0*(c[i-1] + b[i]);
			c[i] := b[i];
			d2 := (y[i+1] - y[i])*3.0*b[i]*b[i]; d[i] := d1 + d2; d1 := d2;
			w[i] := 0; INC(i)
		END ;
		a[i] := 2.0*b[i-1] + hn; d[i] := d1 + dn;
		w[i] := 1.0; i := 0;
		WHILE i < n-2 DO c[i] := c[i]/a[i]; a[i+1] := a[i+1] - c[i]*b[i]; INC(i) END ;
		SolveTriDiag(a, b, c, d, n-1); SolveTriDiag(a, b, c, w, n-1); 
		r := d[i];
		d1 := (d[0] + r)/(w[0] + w[i] + x[i+1] - x[i]); i := 0;
		WHILE i < n-1 DO 
			d[i]:=d[i] - d1*w[i]; INC(i) ;
		END ;
		d[i] := d[0]
	END ClosedSpline;

	PROCEDURE spline (x0, y0, n, open: INTEGER; VAR u,v: ARRAY OF INTEGER);
	VAR i: INTEGER; dx, dy, ds: REAL;
			x, xd, y, yd, s: RealVector;
			p, q: PolyVector;
	BEGIN (*from u, v compute x, y, s*)
		x[0] := u[0]; y[0] := v[0]; s[0] := 0;	i := 1;
		WHILE i < n DO
			x[i] := u[i]; dx := x[i] - x[i-1];
			y[i] := v[i]; dy := y[i] - y[i-1];
			s[i] := ABS(dx) + ABS(dy) + s[i-1]; INC(i)
		END ;
		IF open = 1	THEN OpenSpline(s, x, xd, n); OpenSpline(s, y, yd, n)
		ELSE ClosedSpline(s, x, xd, n); ClosedSpline(s, y, yd, n)
		END ;
		(*compute coefficients from x, y, xd, yd, s*)	i := 0;
		WHILE i < n-1 DO
			ds := 1.0/(s[i+1] - s[i]);
			dx := (x[i+1] - x[i])*ds;
			p[i].a := ds*ds*(xd[i] + xd[i+1] - 2.0*dx);
			p[i].b := ds*(3.0*dx - 2.0*xd[i] -xd[i+1]);
			p[i].c := xd[i];
			p[i].d := x[i];
			p[i].t := s[i];
			dy := ds*(y[i+1] - y[i]);
			q[i].a := ds*ds*(yd[i] + yd[i+1] - 2.0*dy);
			q[i].b := ds*(3.0*dy - 2.0*yd[i] - yd[i+1]);
			q[i].c := yd[i];
			q[i].d := y[i];
			q[i].t := s[i]; INC(i)
		END;
		(*display polynomials*)
		i := 0;
		WHILE i < n-1 DO PrintPoly( x0, y0, p[i], q[i], p[i+1].t - p[i].t); INC(i) END
	END spline;

(* Standard Printer procedures *)
 
	PROCEDURE Open*(name, user: ARRAY OF CHAR; password: LONGINT);
	BEGIN 
        FrameX := 94; FrameY := 177; FrameW := 2336; FrameH := 3280; Depth := 1;
		tmp := Files.New("Printer.Tmp"); Files.Set(TMP,tmp,0);
		Write := TmpWrite;	(* Set write procedure to write tmp file *) 
		COPY(name,PrintDevice);	(* save the output name *)
		NEW(font); nofonts := 0;
		CurFont := -1;
		res := 0;	(* say o.k *)
	END Open;

	PROCEDURE ReplConst* (x, y, w, h: INTEGER);
	BEGIN
		IF (w > 0) & (h > 0 ) THEN Pos(x,y+h); Block(w,h) END;
	END ReplConst;

	PROCEDURE UseListFont*(VAR name: ARRAY OF CHAR);
	BEGIN
	(* not implemented *)
	END UseListFont;

	PROCEDURE String* (x, y: INTEGER; VAR s, fname: ARRAY OF CHAR);
	BEGIN
		SetFont(fname,s);
		Pos(x,y);
		WriteString(s);
	END String;

	PROCEDURE ContString* (VAR s, fname: ARRAY OF CHAR);
	BEGIN
		SetFont(fname,s);
		WriteString(s); 
	END ContString;

	PROCEDURE ReplPattern* (x, y, w, h, col: INTEGER);
	BEGIN
		col := ((100 DIV 16) * col) MOD 100 + 1; (* to range 1..100 *)
		Pos(x,y+h);
		Write(port, ESC); Write(port, "*");Write(port, "c");
		WriteInt(w);Write(port, "a");WriteInt(h);Write(port, "b");
		WriteInt(col);Write(port, "g");
		Write(port, "2");Write(port, "P");
	END ReplPattern;

	PROCEDURE Line* (x0, y0, x1, y1: INTEGER);
	BEGIN
		IF x0 = x1 THEN						(* if it is a vertical line *)
			ReplConst(x0,y0,1,ABS(y1-y0));
		ELSIF y0 = y1 THEN				(* if it is a horizontal line *)
			ReplConst(x0,y0,ABS(x1-x0),1);
		ELSE line(x0, y0, x1, y1) END;
	END Line;

	PROCEDURE Circle* (x0, y0, r: INTEGER);
	BEGIN
		circle (x0, y0, r); 
	END Circle;

	PROCEDURE Ellipse*(x0, y0, a, b: INTEGER);
	BEGIN
		ellipse(x0, y0, a, b);
	END Ellipse;

	PROCEDURE Spline* (x0, y0, n, open: INTEGER; VAR X, Y: ARRAY OF INTEGER);
	BEGIN
		spline(x0, y0, n, open ,X, Y);
	END Spline;

	PROCEDURE Picture*(x, y, w, h, mode: INTEGER; adr: LONGINT);
	VAR b: CHAR;
			i,l,xe,ye: INTEGER;
			Line: ARRAY (HPPageWidth+7) DIV 8 OF CHAR;
	BEGIN	(*	the parameter "mode" is not implemented *)
		xe := x + w;
		ye := y + h;
		WHILE y < ye DO 
			Pos(x,y);
			i := x; l:= 0;
			WHILE i < xe DO
				SYSTEM.GET(adr, b); INC(adr);
				Line[l] :=b;INC(l);
				INC(i);
			END;
			IF l > 0 THEN PutRaster(l,Line) END;
			INC(y);
		END;
	END Picture;
 
	PROCEDURE Page* (nofcopies: INTEGER);
	BEGIN
		ClosePage;						(* close graphics page *)
		IF nofcopies > 1 THEN		(* make	a copy from the page *)
			Write(port, ESC); Write(port, "&");Write(port, "I");
			WriteInt(nofcopies);Write(port, "X");
		END;
		Write(port, FF);
	END Page;

	PROCEDURE Spool(me: Oberon.Task);
	BEGIN END Spool;
	
	PROCEDURE UKG;
	BEGIN 
	END UKG;

	PROCEDURE StartSpool;
	BEGIN
		ukg := UKG;	(* HACK *)
	END StartSpool;

	PROCEDURE Close*;
	VAR ch: CHAR;
			i: SHORTINT;
	BEGIN
		open(PrintDevice);			(* open printer devive *)

		Write(port, ESC);Write(port, "E");		(* Reset Printer	*)
		SetRes(300);						(* resolution 330 dpi *)
		definedot;							(* define HP macro for dot *)
		i := 0 ;
		WHILE i < nofonts DO	(* load used fonts *)
			LoadFont(i); INC(i);
		END;

		Files.Set(TMP,tmp,0);	(* copy the temporary file to device *)
		Files.Read(TMP,ch);
		WHILE ~ TMP.eof DO
			Write(port, ch);
			Files.Read(TMP,ch);
		END;
		ClosePage;		(* the page must be ended if it is not so *)
		close;
		font := NIL;
		nofonts := 0 ;
	END Close;

	PROCEDURE UseColor* (red, green, blue: INTEGER);
	BEGIN
	END UseColor;

	PROCEDURE FileWriteProc(port: INTEGER; ch: CHAR);
	BEGIN
		Files.Write(R,ch);
	END FileWriteProc;

	PROCEDURE TmpWriteProc(port: INTEGER; ch: CHAR);
	BEGIN
		Files.Write(TMP,ch);
	END TmpWriteProc;


BEGIN
	M := NIL;
	Width := HPPageWidth;
	Height := HPPageHeight;
	TmpWrite := TmpWriteProc;	
	FileWrite := FileWriteProc;
	Unit := 3048
 END Printer.
 
 
 
