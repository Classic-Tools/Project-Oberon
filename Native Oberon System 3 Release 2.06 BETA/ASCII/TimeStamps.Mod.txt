(*$C OBERON System 3, version 2.0.

Copyright 1996 Team of the Institute of Computer Systems of ETH Zurich, ETH Center, CH-8092 Zurich,
e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon System 3 license contract.
The full text can be downloaded from ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/License.Text
or requested from the above mentioned address.

Under the license terms dated it is in particular (a) prohibited to modify the interface of this module
in any way that disagrees with style or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE TimeStamps; (* EJZ 3.5.95 *)
	(*
		30.5.94 - fixed printing problem (* ps - 30.5.96, ejz - 12.6.96 *)
		12.6.96 - added support for american date format standard
	*)

	IMPORT Files, Display, Display3, Printer, Printer3, Fonts, Objects, Oberon, Gadgets;

	CONST
		DisplayUnit = LONG(10000);

	TYPE
		Frame* = POINTER TO FrameDesc;
		FrameDesc* = RECORD (Gadgets.FrameDesc)
			font: Fonts.Font;
			cap: ARRAY 20 OF CHAR;
			col: INTEGER;
			w: INTEGER;	(* width of gadgets based on display metrics *)
			us: BOOLEAN
		END;

	PROCEDURE Restore(F: Frame; Q: Display3.Mask; x, y, w, h: INTEGER);
	VAR dx: INTEGER;
	BEGIN
		dx := (w - F.w) DIV 2;
		Display3.String(Q, F.col, x + dx, y-F.font.minY, F.font, F.cap, Display.paint);
		Display3.ReplConst(Q, F.col, x + dx, y, F.w, 1, Display.replace);
		IF Gadgets.selected IN F.state THEN
			Display3.FillPattern(Q, Display3.white, Display3.selectpat, x, y, x, y, w, h, Display.paint)
		END
	END Restore;

	PROCEDURE P(x: LONGINT): INTEGER;
	BEGIN RETURN SHORT((x * DisplayUnit + (Printer.Unit-1)) DIV Printer.Unit)
	END P;

	PROCEDURE DR(x: LONGINT): REAL;
	BEGIN RETURN (x * Printer.Unit) / DisplayUnit
	END DR;

	PROCEDURE Print(F: Frame; Q: Display3.Mask; x, y: INTEGER);
		VAR w, h, dsr: INTEGER;
	BEGIN
		Printer3.StringSize(F.cap, F.font.name, w, h, dsr);	(* get dsr in printer metrics / ps - 30.5.96 *)
		Printer3.String(Q, F.col, x+(P(F.W)-P(F.w)) DIV 2, y + dsr, F.font.name, F.cap, Display.paint);
		Printer3.ReplConst(Q, F.col, x, y, P(F.W), 1, Display.replace)
	END Print;

	PROCEDURE Copy*(VAR M: Objects.CopyMsg; from, to: Frame);
	BEGIN
		to.font := from.font;
		to.col := from.col;
		COPY(from.cap, to.cap);
		to.w := from.w; to.us := from.us;
		Gadgets.CopyFrame(M, from, to)
	END Copy;

	PROCEDURE Caption(F: Frame; VAR w, h: INTEGER; newtime: BOOLEAN);
		VAR date, time: LONGINT; i, pw, ph, dsr: INTEGER;
			wr, hr: REAL;
		PROCEDURE Pair(ch: CHAR; x: LONGINT);
		BEGIN
			F.cap[i] := CHR(x DIV 10 + ORD("0"));
			F.cap[i+1] := CHR(x MOD 10 + ORD("0"));
			F.cap[i+2] := ch;
			INC(i, 3)
		END Pair;
	BEGIN
		IF newtime THEN
			Oberon.GetClock(time, date);
			i := 0;
			IF ~F.us THEN
				Pair(".", date MOD 32);
				Pair(".", date DIV 32 MOD 16);
				Pair(" ", date DIV 512 MOD 128)
			ELSE
				Pair("/", date DIV 32 MOD 16);
				Pair("/", date MOD 32);
				Pair(" ", date DIV 512 MOD 128)
			END;
			Pair(":", time DIV 4096 MOD 32);
			Pair(":", time DIV 64 MOD 64);
			Pair(0X, time MOD 64)
		END;
		(* ps - 30.5.96 *)
		Display3.StringSize(F.cap, F.font, w, h, dsr);	(* get width based on display metrics *)
		Printer3.StringSize(F.cap, F.font.name, pw, ph, dsr);	(* get size based on printer  metrics *)
		wr := DR(pw); hr := DR(ph);
		IF w < wr THEN w := SHORT(-ENTIER(-wr)) END; F.w := w;
		IF h < hr THEN h := SHORT(-ENTIER(-hr)) END
	END Caption;

	PROCEDURE Modify(F: Frame; w, h: INTEGER);
		VAR M: Display.ModifyMsg;
	BEGIN
		M.F := F;
		M.res := -1;
		M.id := Display.extend;
		M.mode := Display.display;
		M.x := 0;
		M.y := 0;
		M.X := F.X;
		M.dX := 0;
		M.Y := F.Y;
		M.dY := 0;
		M.W := w;
		M.dW := w-F.W;
		M.H := h;
		M.dH := h-F.H;
		Display.Broadcast(M)
	END Modify;

	PROCEDURE Attributes(F: Frame; VAR M: Objects.AttrMsg);
		VAR w, h: INTEGER;
	BEGIN
		IF M.id = Objects.get THEN
			IF M.name = "Gen" THEN
				M.class := Objects.String;
				M.s := "TimeStamps.New";
				M.res:= 0
			ELSIF M.name = "Color" THEN
				M.class := Objects.Int;
				M.i := F.col;
				M.res := 0
			ELSIF M.name = "Font" THEN
				M.class := Objects.String;
				COPY(F.font.name, M.s);
				M.res:= 0
			ELSIF M.name = "USDate" THEN
				M.class := Objects.Bool; M.b := F.us; M.res:= 0
			ELSIF M.name = "LineupHY" THEN
				M.class := Objects.Int;
				M.i := -F.font.minY;
				M.res := 0
			ELSE
				Gadgets.framehandle(F, M)
			END
		ELSIF M.id = Objects.set THEN
			IF (M.class = Objects.Int) & (M.name = "Color") THEN
				F.col := SHORT(M.i);
				M.res := 0
			ELSIF (M.class = Objects.String) & (M.name = "Font") THEN
				F.font := Fonts.This(M.s);
				Caption(F, w, h, FALSE);
				Modify(F, w, h);
				M.res := 0
			ELSIF (M.class = Objects.Bool) & (M.name = "USDate") THEN
				F.us := M.b; Caption(F, w, h, TRUE);
				Modify(F, w, h); M.res := 0
			ELSE
				Gadgets.framehandle(F, M)
			END
		ELSIF M.id = Objects.enum THEN
			Gadgets.framehandle(F, M);
			M.Enum("Color"); M.Enum("Font"); M.Enum("USDate");
			M.res := 0
		END
	END Attributes;

	PROCEDURE Handle*(F: Objects.Object; VAR M: Objects.ObjMsg);
		VAR
			F1: Frame;
			Q: Display3.Mask;
			x, y, w, h: INTEGER;
	BEGIN
		WITH F: Frame DO
			IF M IS Display.FrameMsg THEN
				WITH M: Display.FrameMsg DO
					IF (M.F = NIL) OR (M.F = F) THEN
						x := M.x + F.X;
						y := M.y + F.Y;
						w := F.W;
						h := F.H;
						IF M IS Display.DisplayMsg THEN
							WITH M: Display.DisplayMsg DO
								IF (M.id = Display.frame) OR (M.F = NIL) THEN
									Gadgets.MakeMask(F, x, y, M.dlink, Q);
									Restore(F, Q, x, y, w, h)
								ELSIF M.id = Display.area THEN
									Gadgets.MakeMask(F, x, y, M.dlink, Q);
									Display3.AdjustMask(Q, x + M.u, y + h - 1 + M.v, M.w, M.h);
									Restore(F, Q, x, y, w, h)
								END
							END
						ELSIF M IS Display.PrintMsg THEN
							Gadgets.MakePrinterMask(F, M.x, M.y, M.dlink, Q);
							Print(F, Q, M.x, M.y)
						ELSE
							Gadgets.framehandle(F, M)
						END
					END
				END
			ELSIF M IS Objects.AttrMsg THEN
				Attributes(F, M(Objects.AttrMsg))
			ELSIF M IS Objects.FileMsg THEN
				WITH M: Objects.FileMsg DO
					Gadgets.framehandle(F, M);
					IF M.id = Objects.store THEN
						Caption(F, w, h, TRUE);
						Modify(F, w, h);
						Files.WriteInt(M.R, F.col);
						Files.WriteString(M.R, F.font.name);
						Files.WriteString(M.R, F.cap)
					ELSIF M.id = Objects.load THEN
						Files.ReadInt(M.R, F.col);
						NEW(F.font);
						Files.ReadString(M.R, F.font.name);
						F.font := Fonts.This(F.font.name);
						Files.ReadString(M.R, F.cap)
					END
				END
			ELSIF M IS Objects.CopyMsg THEN
				WITH M: Objects.CopyMsg DO
					IF M.stamp = F.stamp THEN
						M.obj := F.dlink
					ELSE
						NEW(F1);
						F.stamp := M.stamp;
						F.dlink := F1;
						Copy(M, F, F1);
						M.obj := F1
					END
				END
			ELSE
				Gadgets.framehandle(F, M)
			END
		END
	END Handle;

	PROCEDURE Init*(F: Frame);
	BEGIN
		INCL(F.state, Gadgets.transparent);
		F.font := Fonts.Default; F.col := Display.FG;
		F.us := FALSE;
		Caption(F, F.W, F.H, TRUE);
		F.handle := Handle
	END Init;

	PROCEDURE New*;
		VAR F: Frame;
	BEGIN
		NEW(F); Init(F);
		Objects.NewObj := F
	END New;

END TimeStamps.

Gadgets.Insert TimeStamps.New
