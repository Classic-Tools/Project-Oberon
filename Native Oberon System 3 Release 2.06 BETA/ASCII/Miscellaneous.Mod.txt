(*$C OBERON System 3, version 2.0.

Copyright 1996 Team of the Institute of Computer Systems of ETH Zurich, ETH Center, CH-8092 Zurich,
e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon System 3 license contract.
The full text can be downloaded from ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/License.Text
or requested from the above mentioned address.

Under the license terms dated it is in particular (a) prohibited to modify the interface of this module
in any way that disagrees with style or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Miscellaneous; (*JG 20.5.94 / NW 22.2.88*)

  IMPORT Kernel, Display, Pictures, Files, Viewers, Fonts, Texts, TextFrames, Oberon, SYSTEM, Centronics, V24;
  
  CONST  TAB =  9X; CR = 0DX; LF = 0AX; BitmapId = 39X; 
        StandardMenu = "System.Close System.Copy System.Grow Edit.Search Edit.Store";
        xOn = 11X; xOff = 13X;
  
  VAR W: Texts.Writer;
  		port: INTEGER;

    PROCEDURE Count (VAR name: ARRAY OF CHAR; VAR nofLines: LONGINT; T: Texts.Text);
    VAR R: Texts.Reader; source: Texts.Text; i: LONGINT; ch: CHAR;
    BEGIN
    Texts.WriteString(W, name);
    Texts.Append(T, W.buf);
    NEW(source); Texts.Open(source, name);
    Texts.WriteString(W," counting");
    Texts.Append(T, W.buf);
    Texts.OpenReader(R, source, 0);
    nofLines := 0; i := 0;
    WHILE i < source.len DO
      Texts.Read(R, ch); INC(i);
      IF ch = CR THEN
        LOOP
          Texts.Read(R, ch); INC(i);
          IF ch # CR THEN EXIT END
        END;
        INC(nofLines)
      END
    END;
    Texts.Write(W, " "); Texts.WriteInt(W, nofLines, 1);
    Texts.WriteLn(W);
    Texts.Append(T, W.buf)
    END Count;
  
  PROCEDURE CountLines*;
    VAR par: Oberon.ParList;
      S: Texts.Scanner;
      T: Texts.Text;
      nofLines, totalLines, beg, end, time: LONGINT;
  BEGIN
    T := TextFrames.Text("");
    Oberon.OpenText("Miscellaneous.CountLines", T, 380, 300);
    totalLines := 0;
    par := Oberon.Par;
    Texts.OpenScanner(S, par.text, par.pos); Texts.Scan(S);
    WHILE S.class = Texts.Name DO
          Count(S.s, nofLines, T); totalLines := totalLines + nofLines; Texts.Scan(S)
        END;
        IF (S.class = Texts.Char) & (S.c = "^") THEN Oberon.GetSelection(T, beg, end, time);
          IF time >= 0 THEN Texts.OpenScanner(S, T, beg); Texts.Scan(S);
            IF S.class = Texts.Name THEN
              Count(S.s, nofLines, T); totalLines := totalLines + nofLines
            END
          END
        END;
    Texts.WriteInt(W, totalLines, 1);
    Texts.WriteLn(W);
    Texts.Append(T, W.buf)
  END CountLines;

    PROCEDURE GetSize (VAR name: ARRAY OF CHAR; VAR varSize: LONGINT;
        VAR constSize: INTEGER; VAR codeSize: INTEGER; T: Texts.Text);
    VAR f: Files.File; R: Files.Rider;
    BEGIN
    Texts.WriteString(W, name);
    Texts.Append(T, W.buf);
    f := Files.Old(name);
    IF f # NIL THEN
      Files.Set(R, f, 22);
      Files.ReadLInt(R, varSize);  Files.ReadInt(R, constSize); Files.ReadInt(R, codeSize);
      Texts.WriteString(W, " var "); Texts.WriteInt(W, varSize, 1);
      Texts.WriteString(W, " const "); Texts.WriteInt(W, constSize, 1);
      Texts.WriteString(W, " code "); Texts.WriteInt(W, codeSize, 1)
    ELSE Texts.WriteString(W, " not found")
    END;
    Texts.WriteLn(W);
    Texts.Append(T, W.buf)
    END GetSize;

  PROCEDURE GetObjSize*;
    VAR par: Oberon.ParList;
      S: Texts.Scanner;
      T: Texts.Text;
      constSize: INTEGER;
      codeSize: INTEGER;
            varSize, totalConstSize, totalVarSize, totalCodeSize: LONGINT;
            beg, end, time: LONGINT;
  BEGIN
    T := TextFrames.Text("");
    Oberon.OpenText("Miscellaneous.GetObjSize", T, 380, 300);
    totalVarSize := 0; totalConstSize := 0; totalCodeSize := 0;
    par := Oberon.Par;
    Texts.OpenScanner(S, par.text, par.pos); Texts.Scan(S);
    WHILE S.class = Texts.Name DO
          GetSize(S.s, varSize, constSize, codeSize, T);
          totalVarSize := totalVarSize + varSize;
          totalConstSize := totalConstSize + constSize;
          totalCodeSize := totalCodeSize + codeSize;
          Texts.Scan(S)
        END;
        IF (S.class = Texts.Char) & (S.c = "^") THEN Oberon.GetSelection(T, beg, end, time);
          IF time >= 0 THEN Texts.OpenScanner(S, T, beg); Texts.Scan(S);
            IF S.class = Texts.Name THEN
              GetSize(S.s, varSize, constSize, codeSize, T);
              totalVarSize := totalVarSize + varSize;
              totalConstSize := totalConstSize + constSize;
              totalCodeSize := totalCodeSize + codeSize
            END
          END
    END;
    Texts.WriteString(W, " var "); Texts.WriteInt(W, totalVarSize, 1);
    Texts.WriteString(W, " const "); Texts.WriteInt(W, totalConstSize, 1);
    Texts.WriteString(W, " code "); Texts.WriteInt(W, totalCodeSize, 1);
    Texts.WriteLn(W);
    Texts.WriteInt(W, totalVarSize + totalConstSize + totalCodeSize, 1);
    Texts.WriteLn(W);
    Texts.Append(T, W.buf)
  END GetObjSize;

  PROCEDURE Snapshot*;	(* harry's version - works on 640x480 & 1024x768 Tseng (~S3) *)
  VAR x, y, col, col1: INTEGER; help: LONGINT;
      f: Files.File; S: Texts.Scanner;
      P: Pictures.Picture;
      bytesperpixel, xbytes: LONGINT;
      supported : BOOLEAN;
  
    PROCEDURE ReadByte(adr, o, mask: LONGINT; VAR byte: LONGINT): BOOLEAN;
    VAR shift, msb, res: LONGINT;
    BEGIN	
    	shift := (o MOD 4)* 8;
    	IF (o >= 1000000H) THEN
    		msb := SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET, o) * SYSTEM.VAL(SET, 0F8000000H));
    		DEC(o, msb)
    	END;
    	INC(adr, o);
    	SYSTEM.GET(adr, byte);
    	byte := byte MOD 100H;
    	res := SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET, byte) * SYSTEM.VAL(SET, mask));
    	IF res > 0 THEN RETURN TRUE
    	ELSE RETURN FALSE
    	END
    END ReadByte;
    
    PROCEDURE GetPix(x, y: INTEGER; VAR col: INTEGER);
    VAR
    	adr : LONGINT;
    	offset,pg,setpage, mask, byte: LONGINT;
    BEGIN
    	adr := Display.Map(0);
    	IF bytesperpixel = 0 THEN
    			(* Setup the video page *)
    		offset := LONG(y)*xbytes + (LONG(x) DIV 8);
    		pg := offset DIV 10000H;
    		setpage := SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET, pg) + SYSTEM.VAL(SET, (pg MOD 16) * 16));
    		SYSTEM.PORTOUT(3CDH, CHR(setpage MOD 100H));
    		offset := offset MOD 10000H;
    		mask := SYSTEM.LSH(80H, -(x MOD 8));
    			(* Select bit *)
    		SYSTEM.PORTOUT(3CEH, 8X);
    		SYSTEM.PORTOUT(3CFH, CHR(mask));
    		col := 0;
    			(* Select plane 0 *)
    		SYSTEM.PORTOUT(3CEH, 4X);
    		SYSTEM.PORTOUT(3CFH, 0X);
		IF ReadByte(adr, offset, mask, byte) THEN INC(col, 1) END;
    			(* Select plane 1 *)
    		SYSTEM.PORTOUT(3CEH, 4X);
    		SYSTEM.PORTOUT(3CFH, 1X);
		IF ReadByte(adr, offset, mask, byte) THEN INC(col, 2) END;
    			(* Select plane 2 *)
    		SYSTEM.PORTOUT(3CEH, 4X);
    		SYSTEM.PORTOUT(3CFH, 2X);
		IF ReadByte(adr, offset, mask, byte) THEN INC(col, 4) END;
    			(* Select plane 3 *)
    		SYSTEM.PORTOUT(3CEH, 4X);
    		SYSTEM.PORTOUT(3CFH, 3X);
		IF ReadByte(adr, offset, mask, byte) THEN INC(col, 8) END
    	ELSIF bytesperpixel = 1 THEN
    		offset := LONG(y)*xbytes + LONG(x);
    		pg := offset DIV 10000H;
    		setpage := SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET, pg) + SYSTEM.VAL(SET, (pg MOD 16) * 16));
    		SYSTEM.PORTOUT(3CDH, CHR(setpage MOD 100H));
		IF ReadByte(adr, offset MOD 010000H, 0FFFFH, byte) THEN END;
		col := SHORT(byte)
	ELSE
		HALT(1234)
    	END
    END GetPix;

  BEGIN
  		(* For now - only support 640x480 and 1024x768 modes *)
    IF Display.Width = 640 THEN supported := TRUE; xbytes := 80; bytesperpixel := xbytes DIV Display.Width
    ELSIF Display.Width = 1024 THEN supported := TRUE; xbytes := 1024; bytesperpixel := xbytes DIV Display.Width
    ELSE supported := FALSE
    END;
    IF ~supported THEN
    	Texts.WriteString(W, "Miscellaneous.Snapshot: screen size not supported");
    	Texts.WriteLn(W);  Texts.Append(Oberon.Log, W.buf)
    ELSE
      Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
      IF S.class = Texts.Name THEN
        NEW(P);
        Pictures.Create(P, Display.Width, Display.Height+1, 8);
        f := Files.New(S.s);
        x := 0; y := Display.Height; 
        WHILE  y > 0 DO
          WHILE Display.Width > x DO
            GetPix(x, y, col); Pictures.Dot(P, col, x, Display.Height +1 - y, 0); INC(x)
          END;     
          DEC(y); x := 0;
        END;
        Pictures.Store(P, f, 0, help);
        Files.Register(f);
        Texts.WriteString(W, "Miscellaneous.Snapshot: Created ");
        Texts.WriteString(W, S.s);  Texts.WriteLn(W);  
        Texts.Append(Oberon.Log, W.buf)
      END
    END
  END Snapshot;

(* old - does not work
  PROCEDURE Snapshot*;
  VAR x, y, col, col1: INTEGER; help: LONGINT;
      f: Files.File; S: Texts.Scanner;
      P: Pictures.Picture;
  
    PROCEDURE GetPix(x, y: INTEGER; VAR col: INTEGER);
    VAR
    	adr : LONGINT;
    	tmp : CHAR;
    BEGIN
    	adr := Display.Map(0) + ((LONG(y) - 1) * (Display.Width DIV 2)) + LONG(x);
    	SYSTEM.GET(adr, tmp);
    	col := ORD(tmp);
    	IF ((x MOD 2) = 0) THEN
    		col := col DIV 16
    	ELSE
    		col := col MOD 16
    	END
    END GetPix;

  BEGIN
    Texts.WriteString(W, "Miscellaneous.Snapshot ");
    Texts.Append(Oberon.Log, W.buf);
    IF Display.Width > 640 THEN
      Texts.WriteString(W, "screen size not supported");
    ELSE
      Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
      IF S.class # Texts.Name THEN Texts.WriteString(W, "missing name")
      ELSE
        Texts.WriteString(W, "creating "); Texts.WriteString(W, S.s);
        Texts.Append(Oberon.Log, W.buf);
        NEW(P);
        Pictures.Create(P, Display.Width, Display.Height+1, 8);
        f := Files.New(S.s);
        x := 0; y := Display.Height; 
        WHILE  y > 0 DO
          WHILE Display.Width > x DO
            GetPix(x, y, col); Pictures.Dot(P, col, x, Display.Height +1 - y, 0); INC(x)
          END;     
          DEC(y); x := 0;
        END;
        Pictures.Store(P, f, 0, help);
        Files.Register(f)
      END
    END;
    Texts.WriteLn(W);
    Texts.Append(Oberon.Log, W.buf)
  END Snapshot;
*)

  PROCEDURE MakeAscii*;
    VAR  R: Texts.Reader; S: Texts.Scanner; T: Texts.Text;
      g: Files.File; Wg: Files.Rider; ch: CHAR; name: ARRAY 32 OF CHAR;
  BEGIN
    Texts.WriteString(W, "Miscellaneous.MakeAscii"); Texts.WriteLn(W);
    Texts.Append(Oberon.Log, W.buf);
    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
    WHILE S.class = Texts.Name DO
      COPY(S.s, name); Texts.Scan(S);
      IF (S.class = Texts.Char) & (S.c = "=") THEN Texts.Scan(S);
        IF (S.class = Texts.Char) & (S.c = ">") THEN Texts.Scan(S);
          IF S.class = Texts.Name THEN
            Texts.WriteString(W, name); Texts.WriteString(W," => ");
                    Texts.WriteString(W, S.s); Texts.Append(Oberon.Log, W.buf);
                    NEW(T); Texts.Open(T, name);
                    g := Files.New(S.s); Files.Set(Wg, g, 0);
                    Texts.OpenReader(R, T, 0); Texts.Read(R, ch);
                    WHILE ~R.eot DO
                    IF (R.lib IS Fonts.Font) &
                    ((ch >= " ") & (ch < 7FX) OR (ch = TAB) OR (ch = CR)) THEN Files.Write(Wg, ch)
                          END;
                    Texts.Read(R, ch)
                    END;
                    Files.Register(g);
                    Texts.WriteLn(W);
                    Texts.Append(Oberon.Log, W.buf)
          END
        END
      END;
      Texts.Scan(S)
    END;
  END MakeAscii;

    PROCEDURE DOSRead (VAR R: Files.Rider; VAR ch: CHAR);
    BEGIN Files.Read(R, ch);
       IF ch >= 80X THEN
         IF ch = 8EX THEN ch := 80X
           ELSIF ch = 99X THEN ch := 81X
           ELSIF ch = 9AX THEN ch := 82X
           ELSIF ch = 84X THEN ch := 83X
           ELSIF ch = 94X THEN ch := 84X
           ELSIF ch = 81X THEN ch := 85X
         END
      END
    END DOSRead;

  PROCEDURE MakeOberonText*;
    VAR S: Texts.Scanner; T: Texts.Text; f, g: Files.File; Rf, Wg: Files.Rider;
         ch: CHAR; name: ARRAY 32 OF CHAR;
  BEGIN
        Texts.WriteString(W, "Miscellaneous.MakeOberonText"); Texts.WriteLn(W);
        Texts.Append(Oberon.Log, W.buf);
    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
    WHILE S.class = Texts.Name DO
      COPY(S.s, name); Texts.Scan(S);
      IF (S.class = Texts.Char) & (S.c = "=") THEN Texts.Scan(S);
        IF (S.class = Texts.Char) & (S.c = ">") THEN Texts.Scan(S);
          IF S.class = Texts.Name THEN
            Texts.WriteString(W, name); Texts.WriteString(W," => ");
                    Texts.WriteString(W, S.s); Texts.Append(Oberon.Log, W.buf);
                    f := Files.Old(name); Files.Set(Rf, f, 0);
                    g := Files.New(S.s); Files.Set(Wg, g, 0);
                    DOSRead(Rf, ch);
                    WHILE ~Rf.eof DO
                          IF ch # LF THEN Files.Write(Wg, ch) END;
                    DOSRead(Rf, ch)
                    END;
                    Files.Register(g);
                    Texts.WriteLn(W);
                    Texts.Append(Oberon.Log, W.buf)
          END
        END
      END;
      Texts.Scan(S)
    END;
  END MakeOberonText;

    PROCEDURE OberonRead (VAR R: Texts.Reader; VAR ch: CHAR);
    BEGIN Texts.Read(R, ch);
       IF ch >= 80X THEN
         IF ch = 80X THEN ch := 8EX
           ELSIF ch = 81X THEN ch := 99X
           ELSIF ch = 82X THEN ch := 9AX
           ELSIF ch = 83X THEN ch := 84X
           ELSIF ch = 84X THEN ch := 94X
           ELSIF ch = 85X THEN ch := 81X
         END
      END
    END OberonRead;

    PROCEDURE ReadWord (VAR R: Texts.Reader; VAR len: INTEGER; VAR buf: ARRAY OF CHAR);
    BEGIN len := 0;
      WHILE buf[len] > " " DO INC(len); OberonRead(R, buf[len]) END
    END ReadWord;

  PROCEDURE MakeDOSText*;
    VAR  R: Texts.Reader; S: Texts.Scanner; T: Texts.Text;
          g: Files.File; Wg: Files.Rider; termCh: CHAR; pos, len, i: INTEGER;
          name: ARRAY 32 OF CHAR; buf: ARRAY 128 OF CHAR;
  BEGIN
        Texts.WriteString(W, "Miscellaneous.MakeDOSText"); Texts.WriteLn(W);
        Texts.Append(Oberon.Log, W.buf);
    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
    WHILE S.class = Texts.Name DO
      COPY(S.s, name); Texts.Scan(S);
      IF (S.class = Texts.Char) & (S.c = "=") THEN Texts.Scan(S);
        IF (S.class = Texts.Char) & (S.c = ">") THEN Texts.Scan(S);
          IF S.class = Texts.Name THEN
            Texts.WriteString(W, name); Texts.WriteString(W," => ");
                    Texts.WriteString(W, S.s); Texts.Append(Oberon.Log, W.buf);
                    NEW(T); Texts.Open(T, name);
                    g := Files.New(S.s); Files.Set(Wg, g, 0);
                    Texts.OpenReader(R, T, 0); termCh := 0X; pos := 0;
                      OberonRead(R, buf[0]);
                  WHILE ~R.eot DO ReadWord(R, len, buf);
                      IF (termCh = CR) OR (termCh # 0X) & (pos + 1 + len > 78) THEN
                        Files.Write(Wg, CR); Files.Write(Wg, LF); termCh := 0X; pos := 0
                      END;
                      IF termCh # 0X THEN Files.Write(Wg, termCh); INC(pos) END;
                      i := 0;
                      WHILE i # len DO Files.Write(Wg, buf[i]); INC(i) END;
                      pos := pos + len; termCh := buf[i];
                      OberonRead(R, buf[0])
                  END;
                    IF (termCh = CR) OR (termCh # 0X) & (pos + 1 > 78) THEN
                      Files.Write(Wg, CR); Files.Write(Wg, LF); termCh := 0X; pos := 0
                    END;
                    IF termCh # 0X THEN Files.Write(Wg, termCh); INC(pos) END;
                Files.Register(g);
                Texts.WriteLn(W);
                Texts.Append(Oberon.Log, W.buf)
                  END
        END
      END;
      Texts.Scan(S)
    END;
  END MakeDOSText;

    PROCEDURE Do*; (*uh 18.1.93*)
    VAR S: Texts.Scanner; text: Texts.Text; vwr: Viewers.Viewer;
      pos: LONGINT; par: Oberon.ParList; X, Y, res: INTEGER;
      frame: Display.Frame;
    
    PROCEDURE NextLine(text: Texts.Text; pos: LONGINT): LONGINT;
      VAR R: Texts.Reader; ch: CHAR;
    BEGIN
      IF pos < text.len THEN 
        Texts.OpenReader(R, text, pos); Texts.Read(R, ch);
        WHILE ~ R.eot & (ch # 0DX) DO Texts.Read(R, ch) END;
        IF R.eot THEN RETURN -1 ELSE RETURN Texts.Pos(R) END
      ELSE RETURN -1
      END
    END NextLine;
  
  BEGIN
    vwr := Oberon.Par.vwr;
    frame := Oberon.Par.frame;
    text := Oberon.Par.text;
    Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
    NEW(par);
    WHILE S.class = Texts.Name DO
      par.vwr := vwr; par.frame := frame; par.text := text; 
      par.pos := Texts.Pos(S) - 1; pos := NextLine(text, par.pos); 
      Oberon.Call(S.s, par, FALSE, res);
      IF pos > 0 THEN Texts.OpenScanner(S, text, pos); Texts.Scan(S)
      ELSE S.class :=Texts.Inval
      END
    END
  END Do;

	PROCEDURE V24Write(ch: CHAR);
	VAR dr: CHAR;  res: LONGINT;
	BEGIN
		IF V24.Available(port) > 0 THEN 
			V24.Receive(port, dr, res);
			IF dr = xOff THEN
				REPEAT IF V24.Available(port) > 0 THEN V24.Receive(port, dr, res) END UNTIL dr = xOn
			END
		END;
		V24.Send(port, ch, res)
	END V24Write;
	
	PROCEDURE PrintFiles*;
	VAR S: Texts.Scanner; Port, fname: ARRAY 32 OF CHAR;
			f: Files.File; R: Files.Rider; ch: CHAR;  res: LONGINT;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		IF (S.class = Texts.Name) OR (S.class = Texts.String) THEN
			COPY(S.s, Port); Texts.Scan(S);
			WHILE (S.class = Texts.Name) OR (S.class = Texts.String) DO
				COPY(S.s, fname); Texts.WriteString(W, fname); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
				IF (Port = "COM1") OR (Port = "COM2") THEN
					IF Port = "COM1" THEN port := 0 ELSE port := 1 END;
					V24.Start(port, 9600, 8, V24.ParNo, 1, res);  ASSERT(res = 0);
					f := Files.Old(fname);
					IF f # NIL THEN 
						Files.Set(R, f, 0); Files.Read(R, ch);
						(*WHILE ch # "%" DO Files.Read(R, ch) END;*)
						WHILE ~R.eof DO V24Write(ch); Files.Read(R, ch) END; 
						(*V24Write(4X);
						REPEAT IF V24.Available(port) > 0 THEN V24.Receive(port, ch) END UNTIL ch = 4X;*)
						V24.Stop(port);
						Files.Close(f);
					ELSE Texts.WriteString(W, "file not found"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf) END;
				ELSIF (Port = "LPT1") OR (Port = "LPT2") OR (Port = "LPT3") THEN
					IF Port = "LPT1" THEN port := Centronics.LPT1 
					ELSIF Port = "LPT2" THEN port := Centronics.LPT2
					ELSE port := Centronics.LPT3 END;
					Centronics.Start(port);
					f := Files.Old(fname);
					IF f # NIL THEN 
						Files.Set(R, f, 0); Files.Read(R, ch);
						(*WHILE ch # "%" DO Files.Read(R, ch) END;*)
						WHILE ~R.eof DO Centronics.Send(port, ch); Files.Read(R, ch) END; 
						(*Centronics.Send(port, 4X);*)
						Files.Close(f)
					ELSE Texts.WriteString(W, "file not found"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf) 
					END
				ELSE Texts.WriteString(W, "not a valid port"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf) 
				END;
				Texts.Scan(S)
			END
		ELSE Texts.WriteString(W, "no port specified"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf) 
		END
	END PrintFiles;

BEGIN Texts.OpenWriter(W)
END Miscellaneous.

