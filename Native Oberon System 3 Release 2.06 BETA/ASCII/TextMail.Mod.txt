(*$C OBERON System 3, version 2.0.

Copyright 1996 Team of the Institute of Computer Systems of ETH Zurich, ETH Center, CH-8092 Zurich,
e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon System 3 license contract.
The full text can be downloaded from ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/License.Text
or requested from the above mentioned address.

Under the license terms dated it is in particular (a) prohibited to modify the interface of this module
in any way that disagrees with style or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE TextMail;	(*RS, Sat, 8-Aug-1994*)
(* ARD, 15.12.94, Stream version *)
(* ARD, 30.01.95, ISO charset version *)
(* ARD, 15.2.95, 8-bit version *)

	IMPORT Texts, TextFrames, Oberon, Viewers, MenuViewers, NS := NetSystem, Display, Fonts;
	
	CONST
		POP = 110;	SMTP = 25;
		CR = 0DX; LF = 0AX; TAB = 9X;

	VAR
		res*: INTEGER;
		W: Texts.Writer;
		host: ARRAY 32 OF CHAR;
		dot: ARRAY 2 OF CHAR;
		ISOToOberon, OberonToISO: ARRAY 256 OF CHAR;
		iso, quoted: BOOLEAN;
		
	PROCEDURE String(s: ARRAY OF CHAR);
	BEGIN
		Texts.WriteString(W, s); Texts.Append(Oberon.Log, W.buf)
	END String;

	PROCEDURE Ln;
	BEGIN
		Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
	END Ln;

	PROCEDURE Response(S: NS.Connection; VAR s: ARRAY OF CHAR);
	BEGIN NS.ReadString(S, s);
		WHILE s[3] = "-" DO NS.ReadString(S, s) END	(*skip multiple response lines*)
	END Response;

	PROCEDURE OpenViewer(name: ARRAY OF CHAR; T: Texts.Text; user: BOOLEAN);
	VAR V: MenuViewers.Viewer; X, Y: INTEGER;
			menu: ARRAY 128 OF CHAR;
			t: TextFrames.Frame;
	BEGIN X := Oberon.Mouse.X;
		IF user THEN
			Oberon.AllocateUserViewer(Oberon.UserTrack(X), X, Y);
			menu := "System.Close System.Copy System.Grow Edit.Search Edit.Store"
		ELSE
			Oberon.AllocateSystemViewer(Oberon.SystemTrack(X), X, Y);
			menu := "System.Close  TextMail.Show  TextMail.Delete  Edit.Search  Edit.Store";
		END;
		V := MenuViewers.New(TextFrames.NewMenu(name, menu), TextFrames.NewText(T, 0), TextFrames.menuH, X, Y);
	END OpenViewer;

	PROCEDURE Connect(VAR S: NS.Connection; host: ARRAY OF CHAR; port: INTEGER; VAR res: INTEGER);
	VAR ip: NS.IPAdr;
	BEGIN NS.GetIP(host, ip);
		NEW(S); NS.OpenConnection(S, NS.anyport, ip, port, res); 
	END Connect;

	PROCEDURE SendCmd(S: NS.Connection; cmd, arg: ARRAY OF CHAR);
	VAR buf: ARRAY 256 OF CHAR; i, j: INTEGER;
	BEGIN i := 0;
		WHILE cmd[i] # 0X DO buf[i] := cmd[i]; INC(i) END;
		IF arg[0] # 0X THEN buf[i] := " "; INC(i); j := 0;
			WHILE arg[j] # 0X DO buf[i] := arg[j]; INC(i); INC(j) END
		END;
		buf[i] := CR; buf[i+1] := LF; buf[i+2] := 0X;
		NS.WriteBytes(S, 0, i+2, buf)
	END SendCmd;

	PROCEDURE Prefix(t: ARRAY OF CHAR; VAR s: ARRAY OF CHAR): BOOLEAN;
	VAR i: INTEGER;
	BEGIN i := 0;
		WHILE (t[i] # 0X) & (t[i] = s[i]) DO INC(i) END;
		RETURN (t[i] = 0X)
	END Prefix;

	PROCEDURE Copy(i: INTEGER; VAR s, t: ARRAY OF CHAR);	(*chop off first i characters*)
	VAR j: INTEGER;
	BEGIN j := 0;
		WHILE s[i] = " " DO INC(i) END;	(*skip leading blanks*)
		WHILE s[i] # 0X DO t[j] := s[i]; INC(j); INC(i) END; t[j] := 0X
	END Copy;

	PROCEDURE IsHexDigit(ch: CHAR): BOOLEAN;
	BEGIN
		RETURN ((ch >= "0") & (ch <= "9")) OR ((ch >= "A") & (ch <= "F"))
	END IsHexDigit;

	PROCEDURE HexVal(ch: CHAR): INTEGER;
	BEGIN
		IF (ch >= "0") & (ch <= "9") THEN RETURN ORD(ch)-ORD("0")
		ELSIF (ch >= "A") & (ch <= "F") THEN RETURN ORD(ch)-ORD("A")+10 END
	END HexVal;

	PROCEDURE WriteStringI2O(VAR W: Texts.Writer; VAR str: ARRAY OF CHAR; quoted: BOOLEAN);
	VAR i: LONGINT; ch: CHAR;
	BEGIN
		i := 0;
		WHILE str[i] # 0X DO
			ch := str[i];
			IF iso THEN 
				IF quoted & (ch = "=") & IsHexDigit(str[i+1]) & IsHexDigit(str[i+2]) THEN
					ch := ISOToOberon[HexVal(str[i+1])*16+HexVal(str[i+2])];
					INC(i, 2)
				ELSE ch := ISOToOberon[ORD(ch)] END
			END;
			Texts.Write(W, ch);
			INC(i)
		END
	END WriteStringI2O;
	
(*	PROCEDURE WriteString(VAR W: Texts.Writer; s: ARRAY OF CHAR);
	VAR i: INTEGER;
	BEGIN i := 0;
		WHILE s[i] # 0X DO Texts.Write(W, s[i]); INC(i) END
	END WriteString;*)

	PROCEDURE ReceiveHead(S: NS.Connection; dir, full: BOOLEAN);
	VAR from, subject, date: ARRAY 256 OF CHAR; to: BOOLEAN;
			s: ARRAY 1024 OF CHAR; i: INTEGER; 
	BEGIN
		NS.ReadString(S, s); subject[0] := 0X; from[0] := 0X; date[0] := 0X; to := FALSE;
		IF s[0] = "+" THEN NS.ReadString(S, s); iso := FALSE; quoted := FALSE;
			WHILE s[0] # 0X DO
				IF full THEN WriteStringI2O(W, s, FALSE); Texts.WriteLn(W);
					IF Prefix("Content-Type:", s) THEN 
						i := 0;
						WHILE (s[i] # 22X) & (s[i] # 0X) DO INC(i) END;
						IF s[i] = 22X THEN
							IF (CAP(s[i+1]) = "I") & (CAP(s[i+2]) = "S") & (CAP(s[i+3]) = "O") THEN iso := TRUE END
						END
					ELSIF Prefix("Content-Transfer-Encoding:", s) THEN 
						i := 0;
						WHILE (s[i] # 22X) & (s[i] # 0X) DO INC(i) END;
						IF s[i] = 22X THEN
							IF (CAP(s[i+1]) = "8") & (CAP(s[i+2]) = "B") & (CAP(s[i+3]) = "I") & (CAP(s[i+4]) = "T") THEN quoted := FALSE 
							ELSIF iso THEN quoted := TRUE
							END
						END
					END;
				ELSIF Prefix("From:", s) THEN
					IF dir THEN Copy(5+1,s, from) ELSE WriteStringI2O(W, s, quoted); Texts.WriteLn(W) END;
				ELSIF Prefix("Subject:", s) THEN
					IF dir THEN Copy(8+1, s, subject) ELSE WriteStringI2O(W, s, quoted); Texts.WriteLn(W) END;
				ELSIF Prefix("To:", s) THEN
					IF ~dir THEN WriteStringI2O(W, s, quoted); Texts.WriteLn(W) END;
					to := ~dir;
				ELSIF Prefix("Cc:", s) OR Prefix("cc:", s) THEN
					IF ~dir THEN WriteStringI2O(W, s, quoted); Texts.WriteLn(W) END;
					to := ~dir;
				ELSIF Prefix("Date:", s) THEN
					IF dir THEN Copy(5+1, s, date) ELSE WriteStringI2O(W, s, quoted); Texts.WriteLn(W) END;
				ELSIF Prefix("Content-Type:", s) THEN 
					i := 0;
					WHILE (s[i] # 22X) & (s[i] # 0X) DO INC(i) END;
					IF s[i] = 22X THEN
						IF (CAP(s[i+1]) = "I") & (CAP(s[i+2]) = "S") & (CAP(s[i+3]) = "O") THEN iso := TRUE END
					END;
				ELSIF ((s[0] = " ") OR (s[0] = TAB)) & to THEN	(*multiple lines*)
					WriteStringI2O(W, s, quoted); Texts.WriteLn(W);
				ELSE to := FALSE
				END;
				NS.ReadString(S, s);
			END;
			IF dir THEN
				WriteStringI2O(W, date, quoted); Texts.Write(W, " ");
				WriteStringI2O(W, from, quoted); Texts.Write(W, " ");
				WriteStringI2O(W, subject, quoted); Texts.WriteLn(W);
			END
		END
	END ReceiveHead;

	PROCEDURE Body(S: NS.Connection);
	VAR s: ARRAY 1024 OF CHAR;
	BEGIN NS.ReadString(S, s);
		WHILE (s[0] # ".") OR (s[1] # 0X) DO
			WriteStringI2O(W, s, quoted); Texts.WriteLn(W); NS.ReadString(S, s)
		END
	END Body;

	PROCEDURE Close(S: NS.Connection);
	VAR s: ARRAY 256 OF CHAR;
	BEGIN SendCmd(S, "quit", ""); NS.ReadString(S, s); NS.CloseConnection(S)
	END Close;

	PROCEDURE OpenPop(VAR S: NS.Connection; host: ARRAY OF CHAR; VAR mails: INTEGER): BOOLEAN;
	VAR s: ARRAY 256 OF CHAR; i: INTEGER;  user, passwd: ARRAY 16 OF CHAR;
	BEGIN
		Connect(S, host, POP, res);
		IF res = 0 THEN NS.ReadString(S, s); 
			IF s[0] = "+" THEN
				user := "";  NS.GetPassword("pop", host, user, passwd);
				SendCmd(S, "user", (*NS.*)user); NS.ReadString(S, s); 
				IF s[0] = "+" THEN SendCmd(S, "pass", (*NS.*)passwd); NS.ReadString(S, s);
					IF s[0] = "+" THEN	(*+OK user has N message(s) (X octets).*)
						i := 4; WHILE (s[i] < "0") OR (s[i] > "9") DO INC(i) END;
						mails := 0;
						WHILE (s[i] >= "0") & (s[i] <= "9") DO mails := 10*mails + ORD(s[i])-30H; INC(i) END;
						RETURN TRUE
					ELSE String("wrong password"); Ln END
				ELSE String("no such user"); Ln END
			ELSIF s[0] = 0X THEN String("timed out"); Ln END;
			Close(S)
		ELSE String("no connection"); Ln END;
		RETURN FALSE
	END OpenPop;

	PROCEDURE OpenScanner(pop: BOOLEAN;  VAR S: Texts.Scanner);
	BEGIN
		(*IF Oberon.Par.frame = Oberon.Par.vwr.dsc THEN	(*menu bar*)
			Texts.OpenScanner(S, Oberon.Par.frame(TextFrames.Frame).text, 0);
		ELSE
			Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos)
		END;
		Texts.Scan(S)*)
		IF pop THEN Oberon.OpenScanner(S, "NetSystem.POP")
		ELSE Oberon.OpenScanner(S, "NetSystem.SMTP")
		END;
		IF S.class = Texts.String THEN S.class := Texts.Name END
	END OpenScanner;
	
	PROCEDURE directory;
	VAR Mail: NS.Connection;
			arg: ARRAY 8 OF CHAR;
			text: Texts.Text;
			mails, k: INTEGER;
	BEGIN
		IF OpenPop(Mail, host, mails) THEN
			k := 1; arg := "nnn 0";	(*nn will be replaced by number*)
			WHILE k <= mails DO
				IF k > 99 THEN arg[0] := CHR(k DIV 100 MOD 10 + 30H) ELSE arg[0] := " " END;
				IF k > 9 THEN arg[1] := CHR(k DIV 10 MOD 10 + 30H) ELSE arg[1] := " " END;
				arg[2] := CHR(k MOD 10 + 30H);
				SendCmd(Mail, "top", arg);
				ReceiveHead(Mail, TRUE, FALSE);
				Body(Mail);	(*should be empty*)
				INC(k); 
			END;
			Close(Mail);
			NEW(text); Texts.Open(text, ""); Texts.Append(text, W.buf); 
			OpenViewer(host, text, FALSE)
		END;
	END directory;

	PROCEDURE Directory*;
	VAR S: Texts.Scanner;
	BEGIN OpenScanner(TRUE, S);
		IF S.class = Texts.Name THEN COPY(S.s, host); directory
		ELSE String("mail host missing"); Ln END
	END Directory;

	PROCEDURE MailNo(VAR mail: INTEGER; VAR text: Texts.Text; VAR beg, end: LONGINT);
	VAR f: Display.Frame;
			F: TextFrames.Frame;
			R: Texts.Reader; ch: CHAR;
	BEGIN f := Oberon.Par.frame; mail := 0; text := NIL;
		IF Oberon.Par.vwr.dsc = f THEN	(*menu frame*)
			f := f.next;
			IF (f # NIL) & (f IS TextFrames.Frame) THEN F := f(TextFrames.Frame); text := F.text;
				IF F.sel > 0 THEN
					Texts.OpenReader(R, text, 0); Texts.Read(R, ch); end := 0;
					WHILE ~R.eot & (end <= F.selbeg.pos) DO
						beg := end;
						WHILE ~R.eot & (ch # CR) DO Texts.Read(R, ch) END;
						IF ch = CR THEN INC(mail); end := Texts.Pos(R) END;	(*number starts with 1*)
						Texts.Read(R, ch)
					END
				END
			END
		END
	END MailNo;

	PROCEDURE ReceiveMail(S: NS.Connection; mailno: INTEGER; VAR text: Texts.Text);
	VAR arg: ARRAY 5 OF CHAR;
	BEGIN
		IF mailno > 99 THEN arg[0] := CHR(mailno DIV 100 MOD 10 + 30H) ELSE arg[0] := " " END;
		IF mailno > 9 THEN arg[1] := CHR(mailno DIV 10 MOD 10 + 30H) ELSE arg[1] := " " END;
		arg[2] := CHR(mailno MOD 10 + 30H); arg[3] := 0X;
		SendCmd(S, "retr", arg); ReceiveHead(S, FALSE, TRUE);
		Texts.WriteLn(W);
		Body(S);
		NEW(text); Texts.Open(text, ""); Texts.Append(text, W.buf);
	END ReceiveMail;
	
	PROCEDURE DeleteMail(S: NS.Connection; mailno: INTEGER; VAR done: BOOLEAN);
	VAR s: ARRAY 256 OF CHAR; arg: ARRAY 5 OF CHAR;
	BEGIN
		IF mailno > 99 THEN arg[0] := CHR(mailno DIV 100 MOD 10 + 30H) ELSE arg[0] := " " END;
		IF mailno > 9 THEN arg[1] := CHR(mailno DIV 10 MOD 10 + 30H) ELSE arg[1] := " " END;
		arg[2] := CHR(mailno MOD 10 + 30H); arg[3] := 0X;
		SendCmd(S, "dele", arg); NS.ReadString(S, s);
		done := (s[0] = "+")
	END DeleteMail;
	
	PROCEDURE receive;
	VAR Mail: NS.Connection;
			text: Texts.Text; d: LONGINT;
			n, mails: INTEGER;
			done: BOOLEAN;
	BEGIN
		IF OpenPop(Mail, host, mails) THEN
			IF mails > 0 THEN
				ReceiveMail(Mail, 1, text);
				OpenViewer("Mail.Text", text, TRUE);
				DeleteMail(Mail, 1, done);
				IF ~done THEN String("deleting failed"); Ln END
			ELSE String("mailbox empty"); Ln END;
			Close(Mail)
		END
	END receive;

	PROCEDURE Receive*;
	VAR S: Texts.Scanner;
	BEGIN OpenScanner(TRUE, S);
		IF S.class = Texts.Name THEN COPY(S.s, host); receive
		ELSE String("mail host missing"); Ln END
	END Receive;

	PROCEDURE show;
	VAR Mail: NS.Connection;
			text: Texts.Text; d: LONGINT;
			n, mails: INTEGER;
	BEGIN
		MailNo(n, text, d, d);
		IF (n > 0) & OpenPop(Mail, host, mails) THEN
			IF n <= mails THEN
				ReceiveMail(Mail, n, text);
				OpenViewer("Mail.Text", text, TRUE)
			ELSE String("no such mail"); Ln END;
			Close(Mail)
		END
	END show;

	PROCEDURE Show*;
	VAR S: Texts.Scanner;
	BEGIN OpenScanner(TRUE, S);
		IF S.class = Texts.Name THEN COPY(S.s, host); show
		ELSE String("mail host missing"); Ln END
	END Show;

	PROCEDURE delete;
	VAR Mail: NS.Connection;
			text: Texts.Text; beg, end: LONGINT;
			n, mails: INTEGER;
			done: BOOLEAN;
	BEGIN
		MailNo(n, text, beg, end);
		IF (n > 0) & OpenPop(Mail, host, mails) THEN
			IF n <= mails THEN
				DeleteMail(Mail, n, done);
				IF done THEN Texts.Delete(text, beg, end) END
			END;
			Close(Mail)
		ELSE String("no connection"); Ln END
	END delete;
	
	PROCEDURE Delete*;
	VAR S: Texts.Scanner;
	BEGIN OpenScanner(TRUE, S);
		IF S.class = Texts.Name THEN COPY(S.s, host); delete
		ELSE String("mail host missing"); Ln END
	END Delete;

	(*--SMTP--*)
	
(*	PROCEDURE ReadString(VAR R: Texts.Reader; VAR s: ARRAY OF CHAR);
	VAR i: INTEGER; ch: CHAR;
	BEGIN i := 0; Texts.Read(R, ch);
		WHILE ~R.eot & (ch # CR) DO
			s[i] := ch; INC(i); Texts.Read(R, ch)
		END;
		s[i] := 0X
	END ReadString;*)

	PROCEDURE HexDigit(i: INTEGER): CHAR;
	BEGIN
		IF i < 10 THEN RETURN CHR(i+ORD("0")) ELSE RETURN CHR(i+ORD("A")-10) END;
	END HexDigit;

	PROCEDURE ReadStringO2I(VAR R: Texts.Reader; VAR s: ARRAY OF CHAR; quoted: BOOLEAN);
	VAR i: INTEGER;
			ch, iso: CHAR;
	BEGIN
		i := 0;
		Texts.Read(R, ch);
		WHILE ~R.eot & (ch # CR) DO
			IF R.lib IS Fonts.Font THEN
				iso := OberonToISO[ORD(ch)];
				IF ~quoted OR ((iso < CHR(128)) & (iso # "=")) THEN s[i] := iso
				ELSE
					s[i] := "=";
					s[i+1] := HexDigit((ORD(iso) DIV 16) MOD 16);
					s[i+2] := HexDigit(ORD(iso) MOD 16);
					INC(i, 2)
				END;
				INC(i)
			END;
			Texts.Read(R, ch)
		END;
		s[i] := 0X
	END ReadStringO2I;

	PROCEDURE Recipient(VAR i: INTEGER; VAR s, rcpt: ARRAY OF CHAR);
	VAR j: INTEGER;
	BEGIN j := 0;
		WHILE (s[i] # 0X) & (s[i] < "0") DO INC(i) END;
		WHILE (s[i] >= "0") OR (s[i] = ".") OR (s[i] = "%") OR (s[i] = "-") DO rcpt[j] := s[i]; INC(j); INC(i) END;
		rcpt[j] := 0X
	END Recipient;

	PROCEDURE SendText(S: NS.Connection; VAR R: Texts.Reader);
	VAR s: ARRAY (*2048*) 512 OF CHAR; t: ARRAY 32 OF CHAR; i, j: INTEGER;
	BEGIN
		s := "Mime-Version: 1.0"; NS.WriteString(S, s);
		s := "Content-Type: text/plain; charset=";
		i := 0; WHILE s[i] # 0X DO INC(i) END; s[i] := 22X; INC(i);
		t := "iso-8859-1";
		j := 0; WHILE t[j] # 0X DO s[i] := t[j]; INC(j); INC(i) END; s[i] := 22X; INC(i); s[i] := 0X;
		NS.WriteString(S, s);
		s := "Content-Transfer-Encoding: 8bit"; NS.WriteString(S, s);
		s := "X-Mailer: Original Oberon-mailer by RS/ARD"; NS.WriteString(S, s);
		REPEAT
			ReadStringO2I(R, s, FALSE);
			IF (s[0] = ".") & (s[1] = 0X) THEN s[1] := "."; s[2] := 0X END;	(*safety*)
			SendCmd(S, s, "")
		UNTIL R.eot;
		SendCmd(S, dot, "")
	END SendText;
	
	PROCEDURE MarkedText(): Texts.Text;
	VAR V, F: Display.Frame;
	BEGIN V := Oberon.MarkedViewer();
		IF (V # NIL) & (V.dsc # NIL) THEN F := V.dsc.next;
			IF (F # NIL) & (F IS TextFrames.Frame) THEN
				RETURN F(TextFrames.Frame).text
			END
		END;
		RETURN NIL
	END MarkedText;

	PROCEDURE send;
	VAR Mail: NS.Connection;
			R: Texts.Reader; text: Texts.Text;
			s, t: ARRAY 2048 OF CHAR;
			rcpt: ARRAY 64 OF CHAR; i: INTEGER;
			user, pwd: ARRAY 16 OF CHAR;
	BEGIN
		text := MarkedText();
		IF text # NIL THEN
			Texts.OpenReader(R, text, 0); ReadStringO2I(R, t, FALSE);	(*valid mail text*)
			IF Prefix("To:", t) THEN Connect(Mail, host, SMTP, res);
				IF res = 0 THEN String("mailing");
					Response(Mail, s);
					IF s[0] = "2" THEN	(*connected*)
						SendCmd(Mail, "HELO", NS.hostName); Response(Mail, s);
						IF s[0] = "2" THEN
							user := "";  NS.GetPassword("pop", host, user, pwd);
							SendCmd(Mail, "MAIL FROM:", (*NS.*)user); Response(Mail, s);
							IF s[0] = "2" THEN
								REPEAT
									i := 3;	(*set behind "To:", "Cc:", "cc:"*)
									Recipient(i, t, rcpt);
									WHILE rcpt[0] # 0X DO
										SendCmd(Mail, "RCPT TO:", rcpt); Response(Mail, s);
										IF s[0] # "2" THEN String(rcpt); String(" not found"); Ln END;
										Recipient(i, t, rcpt)
									END;
									ReadStringO2I(R, t, FALSE)
								UNTIL ~Prefix("To:", t) & ~Prefix("Cc:", t) & ~Prefix("cc:", t);
								SendCmd(Mail, "DATA", ""); Response(Mail, s);
								IF s[0] = "3" THEN
									Texts.OpenReader(R, text, 0); SendText(Mail, R); Response(Mail, s);
									IF s[0] = "2" THEN String(" done") ELSE String(" not done") END;
									Ln
								END
							END
						END
					ELSE String(" failed (mailer)"); Ln END;
					Close(Mail)
				ELSE NS.CloseConnection(Mail); String("no connection"); Ln END
			ELSE String("no recipient"); Ln END
		END
	END send;
	
	PROCEDURE Send*;
	VAR S: Texts.Scanner;
	BEGIN OpenScanner(FALSE, S);
		IF S.class = Texts.Name THEN COPY(S.s, host); send
		ELSE String("mail host missing"); Ln END
	END Send;
	
    PROCEDURE Cite*;
      VAR  V: Viewers.Viewer; R: Texts.Reader; T: TextFrames.Frame;
        pos, beg, end, time: LONGINT; ch: CHAR;
    BEGIN
      V := Oberon.MarkedViewer();
      IF (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN
        T := V.dsc.next(TextFrames.Frame);
        IF T.sel > 0 THEN
          pos := T.selbeg.org; end := T.selend.pos;
          REPEAT
            Texts.WriteString(W, "> "); Texts.Insert(T.text, pos, W.buf);
            Texts.OpenReader(R, T.text, pos); Texts.Read(R, ch); INC(pos);
            WHILE (pos # end) & (ch # CR) DO Texts.Read(R, ch); INC(pos) END
          UNTIL pos = end
        END
      END
    END Cite;

	PROCEDURE Init;
		VAR i: INTEGER;
	BEGIN
		FOR i := 0 TO 255 DO
			ISOToOberon[i] := CHR(i);
			OberonToISO[i] := CHR(i)
		END;
(* 128 .. 191 ? *)
		ISOToOberon[192] := CHR(65);
		ISOToOberon[193] := CHR(65);
		ISOToOberon[194] := CHR(65);
		ISOToOberon[195] := CHR(65);
		ISOToOberon[196] := CHR(128); OberonToISO[128] := CHR(196);
		ISOToOberon[197] := CHR(65);
		ISOToOberon[198] := CHR(65);
		ISOToOberon[199] := CHR(67);
		ISOToOberon[200] := CHR(69);
		ISOToOberon[201] := CHR(69);
		ISOToOberon[202] := CHR(69);
		ISOToOberon[203] := CHR(69);
		ISOToOberon[204] := CHR(73);
		ISOToOberon[205] := CHR(73);
		ISOToOberon[206] := CHR(73);
		ISOToOberon[207] := CHR(73);
		ISOToOberon[208] := CHR(68);
		ISOToOberon[209] := CHR(78);
		ISOToOberon[210] := CHR(79);
		ISOToOberon[211] := CHR(79);
		ISOToOberon[212] := CHR(79);
		ISOToOberon[213] := CHR(79);
		ISOToOberon[214] := CHR(129); OberonToISO[129] := CHR(214);
(* 215 ? *)
		ISOToOberon[216] := CHR(79);
		ISOToOberon[217] := CHR(85);
		ISOToOberon[218] := CHR(85);
		ISOToOberon[219] := CHR(85);
		ISOToOberon[220] := CHR(130); OberonToISO[130] := CHR(220);
		ISOToOberon[221] := CHR(89);
		ISOToOberon[222] := CHR(80);
		ISOToOberon[223] := CHR(150); OberonToISO[150] := CHR(223);
		ISOToOberon[224] := CHR(139); OberonToISO[139] := CHR(224);
		ISOToOberon[225] := CHR(148); OberonToISO[148] := CHR(225);
		ISOToOberon[226] := CHR(134); OberonToISO[134] := CHR(226);
		ISOToOberon[227] := CHR(97);
		ISOToOberon[228] := CHR(131); OberonToISO[131] := CHR(228);
		ISOToOberon[229] := CHR(97);
		ISOToOberon[230] := CHR(97);
		ISOToOberon[231] := CHR(147); OberonToISO[147] := CHR(231);
		ISOToOberon[232] := CHR(140); OberonToISO[140] := CHR(232);
		ISOToOberon[233] := CHR(144); OberonToISO[144] := CHR(233);
		ISOToOberon[234] := CHR(135); OberonToISO[135] := CHR(234);
		ISOToOberon[235] := CHR(145); OberonToISO[145] := CHR(235);
		ISOToOberon[236] := CHR(141); OberonToISO[141] := CHR(236);
		ISOToOberon[237] := CHR(105);
		ISOToOberon[238] := CHR(136); OberonToISO[136] := CHR(238);
		ISOToOberon[239] := CHR(146); OberonToISO[146] := CHR(239);
		ISOToOberon[240] := CHR(100);
		ISOToOberon[241] := CHR(149); OberonToISO[149] := CHR(241);
		ISOToOberon[242] := CHR(142); OberonToISO[142] := CHR(242);
		ISOToOberon[243] := CHR(111);
		ISOToOberon[244] := CHR(137); OberonToISO[137] := CHR(244);
		ISOToOberon[245] := CHR(111);
		ISOToOberon[246] := CHR(132); OberonToISO[132] := CHR(246);
		ISOToOberon[248] := CHR(111);
		ISOToOberon[249] := CHR(143); OberonToISO[143] := CHR(249);
		ISOToOberon[250] := CHR(117);
		ISOToOberon[251] := CHR(138); OberonToISO[138] := CHR(251);
		ISOToOberon[252] := CHR(133); OberonToISO[133] := CHR(252);
		ISOToOberon[253] := CHR(121);
		ISOToOberon[254] := CHR(112);
		ISOToOberon[255] := CHR(121)
	END Init;

BEGIN Texts.OpenWriter(W);
	dot[0] := "."; dot[1] := 0X; Init
END TextMail.
