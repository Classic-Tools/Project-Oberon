(*$C OBERON System 3, version 2.0.

Copyright 1996 Team of the Institute of Computer Systems of ETH Zurich, ETH Center, CH-8092 Zurich,
e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon System 3 license contract.
The full text can be downloaded from ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/License.Text
or requested from the above mentioned address.

Under the license terms dated it is in particular (a) prohibited to modify the interface of this module
in any way that disagrees with style or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE DocumentSkeleton; 
(*
	DocumentSkeleton.Mod, jm 25.10.93

	A trivial example of a document. It implements a document that
	consists of a panel, only the color of which is stored.
	
	1.11.95 - Modified to support document attachments
*)

IMPORT
	Files, Objects, Display, Texts, Oberon, Links, Documents, Desktops, Gadgets;

VAR
	W: Texts.Writer;
	
PROCEDURE Cycle*;
VAR doc: Documents.Document; F: Gadgets.Frame; A: Objects.AttrMsg;
BEGIN
	doc := Desktops.CurDoc(Gadgets.context);
	IF (doc # NIL) & (doc.dsc IS Gadgets.Frame) THEN
		F := doc.dsc(Gadgets.Frame);
		A.id := Objects.get; A.name := "Color"; A.res := -1; F.handle(F, A);
		IF (A.res >= 0) & (A.class = Objects.Int) THEN
			A.i := (A.i + 1) MOD 4;
			A.id := Objects.set; A.res := -1; F.handle(F, A);
			Gadgets.Update(F)
		END;
	END
END Cycle;
	
PROCEDURE Load(D: Documents.Document);
VAR
	obj: Objects.Object;
	tag, x, y, w, h, col: INTEGER;
	filename, name: ARRAY 64 OF CHAR; F: Files.File; R: Files.Rider; A: Objects.AttrMsg; ch: CHAR;
	CM: Gadgets.CmdMsg;
BEGIN
	obj := Gadgets.CreateObject("Panels.NewPanel");
	WITH obj: Gadgets.Frame DO
		x := 0; y := 0; w := 250; h := 200; col := 1; (* default *)
		
		F := Files.Old(D.name);
		IF F # NIL THEN
			Files.Set(R, F, 0);
			Files.ReadInt(R, tag);
			IF tag = Documents.Id THEN
				Files.ReadString(R, name);
				Files.ReadInt(R, x); Files.ReadInt(R, y); Files.ReadInt(R, w); Files.ReadInt(R, h);
				
				(* Attachment support *)
				Files.Read(R, ch); IF ch # 0F7X THEN HALT(99) END;
				Documents.LoadAttachments(R, D.attr, D.link);
				IF D.link # NIL THEN
					CM.cmd := "PREPARE"; CM.res := -1; CM.dlink := D; Objects.Stamp(CM);
					Links.Broadcast(D.link, CM)
				END;
				(* end Attachment support *)
				
				Files.ReadInt(R, col);
			END
		ELSE (* COPY("DefaultName", D.name) *)
		END;
		D.X := x; D.Y := y; D.W := w; D.H := h;
		
		A.id := Objects.set; A.name := "Color"; A.class := Objects.Int; A.res := -1; A.i := col;
		obj.handle(obj, A);
		
		Documents.Init(D, obj)
	END
END Load;

PROCEDURE Store(D: Documents.Document);
VAR obj: Gadgets.Frame; F: Files.File; R: Files.Rider; A: Objects.AttrMsg;
BEGIN
	obj := D.dsc(Gadgets.Frame);
	Texts.WriteString(W, "Store "); Texts.Append(Oberon.Log, W.buf);
	IF D.name # "" THEN
		F := Files.New(D.name);
		IF F = NIL THEN HALT(99) END;

		Files.Set(R, F, 0);
		Files.WriteInt(R, Documents.Id); Files.WriteString(R, "DocumentSkeleton.NewDoc");
		Files.WriteInt(R, D.X); Files.WriteInt(R, D.Y); Files.WriteInt(R, D.W); Files.WriteInt(R, D.H);
		
		(* Attachment support *)
		Documents.StoreAttachments(R, D.attr, D.link);
	
		A.id := Objects.get; A.name := "Color"; A.res := -1; obj.handle(obj, A);
		Files.WriteInt(R, SHORT(A.i));
		Files.Register(F);
		
		Texts.Write(W, 22X); Texts.WriteString(W, D.name); Texts.Write(W, 22X)
	ELSE Texts.WriteString(W, "[Untitled document]")
	END;
	Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
END Store;

PROCEDURE Handler(D: Objects.Object; VAR M: Objects.ObjMsg);
VAR C: Objects.CopyMsg;
BEGIN
	WITH D: Documents.Document DO
		IF M IS Objects.AttrMsg THEN
			WITH M: Objects.AttrMsg DO
				IF M.id = Objects.get THEN
					IF M.name = "Gen" THEN M.class := Objects.String; M.s := "DocumentSkeleton.NewDoc"; M.res := 0
					ELSIF M.name = "Adaptive" THEN M.class := Objects.Bool; M.b := FALSE; M.res := 0
					ELSIF M.name = "Icon" THEN M.class := Objects.String; M.s := "Icons.Tool"; M.res := 0
					ELSIF M.name = "Menu" THEN M.class := Objects.String;
						M.s := "Desktops.StoreDoc[Store] DocumentSkeleton.Cycle"; M.res := 0
					ELSE Documents.Handler(D, M)
					END
				ELSE Documents.Handler(D, M)
				END
			END
		ELSIF M IS Objects.LinkMsg THEN
			WITH M: Objects.LinkMsg DO
				IF (M.id = Objects.get) & (M.name = "DeskMenu") THEN M.obj := Gadgets.FindPublicObj("TestMenus.DeskMenu");
					IF M.obj # NIL THEN C.id := Objects.deep; Objects.Stamp(C); M.obj.handle(M.obj, C); M.obj := C.obj END;
					M.res := 0
				ELSIF (M.id = Objects.get) & (M.name = "SystemMenu") THEN M.obj := Gadgets.FindPublicObj("TestMenus.SystemMenu");
					IF M.obj # NIL THEN C.id := Objects.deep; Objects.Stamp(C); M.obj.handle(M.obj, C); M.obj := C.obj END;
					M.res := 0
				ELSIF (M.id = Objects.get) & (M.name = "UserMenu") THEN M.obj := Gadgets.FindPublicObj("TestMenus.UserMenu");
					IF M.obj # NIL THEN C.id := Objects.deep; Objects.Stamp(C); M.obj.handle(M.obj, C); M.obj := C.obj END;
					M.res := 0
				ELSE Documents.Handler(D, M)
				END
			END
		ELSIF M IS Display.PrintMsg THEN
			WITH M: Display.PrintMsg DO
				IF (M.id = Display.contents) & (D.dsc # NIL) THEN (* print *)
				ELSE Documents.Handler(D, M)
				END
			END
		ELSE Documents.Handler(D, M)
		END
	END
END Handler;

PROCEDURE NewDoc*;
VAR D: Documents.Document;
BEGIN
	NEW(D);
	D.Load := Load; D.Store := Store; D.handle := Handler;
	D.W := 250; D.H := 200;
	Objects.NewObj := D
END NewDoc;

BEGIN Texts.OpenWriter(W)
END DocumentSkeleton.

Desktops.OpenDoc (DocumentSkeleton.NewDoc)